Introduction Quantum computing is poised to provide supremacy over classical computing using quantum mechanical phenomena such as superposition, interference and entanglement. Physical systems like, superconducting circuits 1 , 2 , 3 , 4 , nuclear magnetic resonance (NMR) systems 5 , 6 , 7 , 8 , 9 , ion traps 10 , 11 , ultra-cold atoms in optical lattice 12 , 13 and photonics 14 , 15 , 16 , 17 , 18 have been successfully engineered to demonstrate small scale quantum processors and implement quantum simulations and computational tasks. The noisy-intermediate scale quantum processors we have today are still far from the one that can be used for performing useful tasks that are inaccessible by the existing powerful classical computers. Different models for quantum computation and the engineering of different physical systems and architecture to build scalable processors has been explored for a long time now. For example, measurement based quantum computing model 19 , 20 , 21 , 22 , adiabatic quantum computing model 23 , 24 , 25 , 26 , 27 , and KLM-linear optical quantum computing 15 are some of the examples in addition to standard circuit based quantum computation model. The use of quantum walks 28 , 29 , 30 , 31 , which are part of several quantum algorithms 32 , 33 , 34 developed to outperform classical algorithms at computational tasks has also been proposed to develop a scheme for universal quantum computation model. A quantum walk based quantum computing model was first introduced on unweighted graphs using the continuous-time quantum walk 35 and a corresponding scheme using discrete-time quantum walk was proposed later 36 . Recently, we proposed a new scheme using a single qubit discrete-time quantum walk on a closed lattice setting 37 . Compared to the earlier discrete-time quantum walk scheme which requires a large number of real qubits and higher dimensional coin operations, our scheme defines computation purely as a sequence of position dependent coin and shift operations on a system with a single real qubit and position space as an additional computational basis. With the advent of photonics-based quantum computing systems 17 , 38 and the efficient realization of quantum walks 39 , the potential realizability of our proposed scheme gains more relevance. Decreased resource requirements for implementation of this scheme is one of the major factors that make it experimentally more feasible to implement in any hardware platform where controllable discrete-time quantum walks have been demonstrated. Here we present a detailed extension of the simple, implementable quantum computing scheme using a single particle discrete-time quantum walk which can be scaled to higher dimensions 37 . Along with the position Hilbert space on which the quantum walks are defined, the discrete-time quantum walk provides additional degree of freedom in the form of coin Hilbert space that can be exploited to achieve control over the states to perform computing operations. This model can be implemented on a photonic or lattice based quantum systems where one photon or free particle can act as coin that can be used to perform computation when entangled with the position space. We propose the use of multiple sets of closed graph with four sites and four edges to act as a system with \(2^{(N-1)}\) -dimensional position space. Each graph is equivalent to a two-qubit state and n -sets of closed graph provides 2n-qubit equivalent states. With the help of the coin and shift operations, the coin and position state of the particle can be evolved into the desired output state 40 . We also demonstrate the effectiveness of our scheme by presenting a combination of quantum walk operations to implement the quantum algorithms like Grover’s search algorithm, quantum Fourier transformation and phase estimation algorithms. Further, an elementary implementation of single qubit error detection (3-qubit code) for both bit-flip and phase-flip errors, and error correction using a 5-qubit code is presented. We also discuss the space and time complexity of the scheme in a generic sense to highlight the possible advantages of the quantum walk based scheme. In “ Quantum walk on higher-qubit equivalent systems “, we present a brief discussion on the discrete-time quantum walk and show the scalability of the single qubit quantum computational scheme to N-qubit equivalent system by expanding the position space. “ Implementing hadamard, phase, and controlled-NOT gates on N -qubit equivalent system " shows the implementation of universal gates on this N-qubit equivalent system, and in “ Grover’s search algorithm on three qubit equivalent quantum walk scheme ", “ Quantum Fourier transformation on three-qubit equivalent quantum walk scheme " and “ Phase estimation algorithm on three qubit equivalent quantum walk scheme " we present schemes for realization of Grover’s search algorithm, quantum Fourier transformation and phase estimation algorithm on the DTQW-based system, respectively. We discuss the space and time complexity of quantum walk based scheme in “ Quantum space and time complexity ", and explore a basic implementation of quantum error detection and correction codes in “ Single-qubit error detection ". We present our conclusions and future outlook for this work in “ Conclusion ". Quantum walk on higher-qubit equivalent systems The dynamics of the discrete-time quantum walk on a closed graph is defined on a Hilbert space \(\mathscr {H} = \mathscr {H}_c \otimes \mathscr {H}_p\) where, \(\mathscr {H}_c\) is the coin Hilbert space with internal degrees of freedom and \(\mathscr {H}_p\) is the position Hilbert space defined by closed set of points in the position space 41 . For the computation model proposed in this work, we choose the position Hilbert space to be defined by the multiple sets of closed graphs of 4-states spanned by \(\left| {x}\right\rangle = \{ \left| {0}\right\rangle , \left| {1}\right\rangle , \left| {2}\right\rangle , \left| {3}\right\rangle \}\) . The evolution operation on this setup of discrete-time quantum walk is described by the action of the unitary quantum coin operation \(\hat{C}\) on the coin state followed by the conditional position shift operation on the desired set of closed graph of the position space. The general form of position shift operator for discrete-time quantum walk on a closed graph, that translates to the left or right conditioned on the coin states with \(\mu\) internal degrees of freedom is given as, $$\begin{aligned} \hat{S}_{\pm }^{\alpha } = \sum _{l\in \mathbb {Z}} \left[ \left| {\alpha }\right\rangle \left\langle {\alpha }\right| \otimes \left| {l\pm 1 \mod 4}\right\rangle \left\langle {l}\right| + \sum _{\beta \ne \alpha }^{\mu }\left( \left| {\beta }\right\rangle \left\langle {\beta }\right| \otimes \left| {l}\right\rangle \left\langle {l}\right| \right) \right] . \end{aligned}$$ (1) Here, \(\{\left| {\alpha }\right\rangle ,\left| {\beta }\right\rangle \} \in \mathscr {H}_c\) are the basis states of coin Hilbert space \(\mathscr {H}_c\) and \(\left| {l}\right\rangle\) are the basis states of position Hilbert space \(\mathscr {H}_p\) . The general form of the quantum coin operator with two internal degree of freedom \(\mathscr {H}_c = span \{\left| {0}\right\rangle , \left| {1}\right\rangle \}\) is given by SU(2) operator of the form, $$\begin{aligned} \hat{C}(\xi ,\zeta ,\theta ) = \begin{bmatrix} ~~~~e^{i \xi }\cos (\theta ) &{} ~~~e^{i \zeta }\sin (\theta ) \\ -e^{-i \zeta } \sin (\theta ) &{} e^{-i \xi } \cos (\theta ) \end{bmatrix}. \end{aligned}$$ (2) This set of operators along with the identity operator \(\mathbb {I}\) can be considered a generic set of operators that describes the scalable quantum computation scheme using discrete-time quantum walk, hereafter called the quantum walk in this text. Quantum computation using quantum walk The scheme presented for universal quantum computation on quantum walk for three qubit equivalent system 37 can be scaled to a larger qubit system by using the same coin in conjunction with different sets of closed graph of the position space. This method will expand the shift operator with the increase of the number of closed graphs of four-sites, but can be scaled as far as the scheme goes. The form of shift operators which is used throughout for scaling of the universal computation model for input state \(\left| {k}\right\rangle \bigotimes _{i=1}^{n} \left| {m_i}\right\rangle\) will be given as, $$\begin{aligned} S^k_{j,\pm } = \sum _l \left[ \left| {k}\right\rangle \left\langle {k}\right| \otimes \mathbb {I}^{\otimes j-1} \otimes \left| {l\pm 1 \mod 4}\right\rangle \left\langle {l}\right| \otimes \mathbb {I}^{\otimes n-j} + \left| {p\ne k}\right\rangle \left\langle {p}\right| \otimes \mathbb {I}^{\otimes n} \right] , \end{aligned}$$ (3) where n is the total number of closed graphs and j indicates the closed graph on which the shift operation is performed. \(\{\left| {k}\right\rangle , \left| {p}\right\rangle \} \in \mathscr {H}_c\) are states in the coin Hilbert space with two internal degree of freedom and \(\left| {l}\right\rangle\) represents the four states on the four-site closed graph, and number of closed graph is n . The number of states for this case will be equivalent to the number of states in the combined state of the Hilbert-space \(\mathscr {H}_c \otimes \mathscr {H}_{p}\) , where \(\mathscr {H}_p\) has dimension \(2^{(N-1)}\) , and N is the total number of qubits in the system. The evolution operation on this system can be interpreted as the shift operation on the \(j{\mathrm{th}}\) closed graph representing the ‘selected’ position space and identity operation on the rest of the closed sets of the position space, as shown in Fig. 1 . Figure 1 Scaling of the quantum walk scheme to \(N-\) qubit systems. ( a ) Case where N is even, and ( b ) the case where N is odd. When N is even (case (a)), then \((N/2 -1)\) graphs with four sites and one graph with two sites are required. In case ( b ), \((N-1)/2\) graphs with four sites are required to implement universal quantum computation. Full size image This can be then used to derive the \(\hat{W}\) operator, in order to implement the Hadamard gate on N -qubit system and a specific case of this \(\hat{W}\) -operator is used in Ref. 37 . An N -qubit system will require \(n= \left[ \frac{(N-2)}{2} \right]\) sets of four-site closed graph and one set of two-site graph with one edge if N is even, and \(n= \left[ \frac{(N-1)}{2} \right]\) sets of four-site closed graphs if N is odd. In order to simplify notation, we choose \(\left| {m_j}\right\rangle\) to represent the position state of the \(j{\mathrm{th}}\) set of closed graphs. The complete state of the position space is given by \(\left| {m}\right\rangle\) , which is defined as, $$\begin{aligned} \left| {m}\right\rangle \equiv \bigotimes _{i=1}^{n} \left| {m_i}\right\rangle . \end{aligned}$$ (4) Then, the \(\hat{W}\) operators on state \(\left| {m_j}\right\rangle\) with \(1<j<n\) is defined as, $$\begin{aligned}{} & {} \hat{W}_{j,\pm }^0 \left| {k}\right\rangle \left| {m}\right\rangle = \left[ ( \sigma _x \otimes \left| {m}\right\rangle \left\langle {m}\right| + \mathbb {I}\otimes \sum _{l \ne m} \left| {l}\right\rangle \left\langle {l}\right| ) S^0_{j,\pm } \left( \sigma _x \otimes \mathbb {I}^{\otimes n} \right) \right] \left| {k}\right\rangle \left| {m}\right\rangle , \end{aligned}$$ (5) $$\begin{aligned}{} & {} \hat{W}_{j,\pm }^1 \left| {k}\right\rangle \left| {m}\right\rangle = \left[ ( \sigma _x \otimes \left| {m}\right\rangle \left\langle {m}\right| + \mathbb {I}\otimes \sum _{l \ne m} \left| {l}\right\rangle \left\langle {l}\right| ) S^1_{j,\pm } \left( \sigma _z \otimes \mathbb {I}^{\otimes n} \right) \right] \left| {k}\right\rangle \left| {m}\right\rangle . \end{aligned}$$ (6) A note on notation Here, uppercase letters are used to represent a particular qubit and lowercase letters refer to the order of the closed graph. It may also be observed from Fig. 1 that the \(I \mathrm{th}\) qubit belongs to the closed graph of order \(i = \frac{I}{2}\) if I is even and \(i = \frac{I-1}{2}\) if I is odd. In an abbreviated notation, the shift operator is written as, $$\begin{aligned} S^k_{j,\pm } = \sum _{l,m} \Big [ \left| {k}\right\rangle \left\langle {k}\right| \otimes \left| {l_j\pm 1 \mod 4}\right\rangle \left\langle {l_j}\right| + \left| {m\ne k}\right\rangle \left\langle {m}\right| \otimes \mathbb {I}_p\Big ]. \end{aligned}$$ (7) Implementing Hadamard, Phase, and controlled-NOT gates on an N -qubit equivalent system Hadamard gate In this scheme, the Hadamard gate can be implemented on any qubit of N -qubit equivalent system by redefining the Hadamard gates \(\hat{H}_2\) and \(\hat{H}_3\) in Ref. 37 . Hadamard operation on the j th level of the closed graph, when the coin state is \(\left| {k}\right\rangle\) and position state is \(\left| {m}\right\rangle\) as given by Eq. ( 4 ), can be implemented on the quantum walk scheme by evolving the initial state by using Eq. ( 8 ) when the Hadamard gate is applied on the \((2j){\mathrm{th}}\) -qubit and by using Eq. ( 9 ) when the Hadamard gate is applied on the \((2j+1) \mathrm{th}\) -qubit. $$\begin{aligned} \hat{H}^k_{2,j} \left| {k}\right\rangle \left| {m}\right\rangle= &{} \left[ \hat{W}^{k \mod 2}_{j,-} \left| {0_j}\right\rangle \left\langle {0_j}\right| + \hat{W}^{k \mod 2}_{j,+} \left| {1_j}\right\rangle \left\langle {1_j}\right| + \hat{W}^{(k+1) \mod 2}_{j,-} \left| {3_j}\right\rangle \left\langle {3_j}\right| + \hat{W}^{(k+1) \mod 2}_{j,+} \left| {2_j}\right\rangle \left\langle {2_j}\right| \right] \nonumber \\& {} \left( \hat{H}_1 \otimes \mathbb {I}_2^{\otimes N}\right) , \end{aligned}$$ (8) $$\begin{aligned} \hat{H}^k_{3,j}\left| {k}\right\rangle \left| {m}\right\rangle= & {} \left[ \hat{W}^{k \mod 2}_{j,+} \left| {0_j}\right\rangle \left\langle {0_j}\right| + \hat{W}^{(k+1) \mod 2}_{j,-} \left| {1_j}\right\rangle \left\langle {1_j}\right| + \hat{W}^{(k+1) \mod 2}_{j,+} \left| {3_j}\right\rangle \left\langle {3_j}\right| + \hat{W}^{k \mod 2}_{j,-} \left| {2_j}\right\rangle \left\langle {2_j}\right| \right] \nonumber \\{} & {} \left( \hat{H}_1 \otimes \mathbb {I}_2^{\otimes N}\right) . \end{aligned}$$ (9) Thus, the \(\hat{H}\) corresponds to a position-dependent evolution operator in quantum walk scheme which applies to the appropriate vertices of the desired closed graph in the scaling diagram as shown in Fig. 1 . Here the eigenstates of the 2-qubit equivalent j th closed system are \(\left| {m_j}\right\rangle \, ,m=\{0,1,2,3\}\) . The Hadamard on any qubit \(Q > 1\) can be expressed on discrete-time quantum walk scheme in the form of evolution operator \(\hat{H}^k_{i,j}\) , where \(i \in \{2,3\}\) and j is the level of the closed graph such that the relation between j and Q is \(j = \lfloor \frac{Q}{2} \rfloor\) , i.e., $$\begin{aligned} \hat{H}_Q^k = {\left\{ \begin{array}{ll} \hat{H}^k_{2,j} &{} \text {for even }Q \\ \hat{H}^k_{3,j} &{} \text {for odd }Q. \end{array}\right. } \end{aligned}$$ (10) A special case arises when the last qubit \(Q=N\) is even and scaling is illustrated by Fig. 1(a) . In this case, $$\begin{aligned} \hat{H}^k_Q = \hat{H}^k_{3,n}. \end{aligned}$$ (11) In case \(Q = 1\) , the Hadamard gate can be reduced to a coin operation \(\hat{H}_1 = \hat{C}\left( 0,0,\frac{\pi }{4}\right) =\begin{bmatrix}1 &{} 1\\ 1 &{} -1\end{bmatrix}\) with an identity shift operator. nnPhase gate The phase gate can be implemented on an N -qubit equivalent system in a manner similar to the Hadamard gate. Therefore, phase applied to the \(Q\text {th}\) qubit ( \(Q \in \{2,3,\ldots N\}\) ) can be expressed in terms of the level j of the closed graph as, $$\begin{aligned} \hat{P}_Q = {\left\{ \begin{array}{ll} \hat{P}_{2,j} &{} \text {for even }Q \\ \hat{P}_{3,j} &{} \text {for odd }Q , \end{array}\right. } \end{aligned}$$ (12) where \(\hat{P}_{2,j}\) and \(P_{3,j}\) are given as, $$\begin{aligned} P_{2,j}&= \mathbb {I}\otimes \left( \left| {0_j}\right\rangle \left\langle {0_j}\right| + \left| {1_j}\right\rangle \left\langle {1_j}\right| \right) + e^{i\phi }\mathbb {I}\otimes \left( \left| {3_j}\right\rangle \left\langle {3_j}\right| +\left| {2_j}\right\rangle \left\langle {2_j}\right| \right) \end{aligned}$$ (13) $$\begin{aligned} P_{3,j}&= \mathbb {I}\otimes \left( \left| {0_j}\right\rangle \left\langle {0_j}\right| + \left| {2_j}\right\rangle \left\langle {2_j}\right| \right) + e^{i\phi }\mathbb {I}\otimes \left( \left| {3_j}\right\rangle \left\langle {3_j}\right| +\left| {1_j}\right\rangle \left\langle {1_j}\right| \right) \end{aligned}$$ (14) For the special case when \(Q=N\) is even, analogous to the Hadamard gate, phase gate can be given as, $$\begin{aligned} \hat{P}_N = \hat{P}_{3,n}. \end{aligned}$$ (15) When \(Q=1\) , the phase operation on the first qubit is simply a coin operation, \(C = \begin{bmatrix}1 &{} 0 \\ 0 &{} e^{i\phi }\end{bmatrix}\) with an identity operation on the position space. Controlled-NOT gate Since, controlled-NOT gate (CNOT) is a two qubit gate (unlike Hadamard and phase gate), the gate implementation scheme changes form based on which two qubits are being addressed in the N -qubit equivalent system. The different cases which will cover all the possibilities of controlled-NOT gate between control qubit \(Q_c\) (here assumed to be on the \(i\text {th}\) level) and target qubit \(Q_t\) (assumed to be on the \(j\text {th}\) level) on N -qubit equivalent system (with n levels) are: Case 1: \(Q_c=1\) or \(Q_t=1\) Case 1a: \(Q_c=1\) , \(Q_t\) is even, and \(j=n\) , $$\begin{aligned} CNOT_{1,N} = \Big [ S^1_{j,+}\left( \left| {0_j}\right\rangle \left\langle {0_j}\right| \right) + S^1_{j,-}\left( \left| {1_j}\right\rangle \left\langle {1_j}\right| \right) \Big ]. \end{aligned}$$ (16) Case 1b: \(Q_t=1\) , \(Q_c\) is even, and \(i=n\) , $$\begin{aligned} CNOT_{N,1} = \Big [ \mathbb {I}\otimes \mathbb {I}\left( \left| {0_i}\right\rangle \left\langle {0_i}\right| \right) + \sigma _{x}\otimes \mathbb {I}\left( \left| {1_i}\right\rangle \left\langle {1_i}\right| \right) \Big ]. \end{aligned}$$ (17) Case 1c: \(Q_c=1\) , \(Q_t\) is even, and is on \(j{\mathrm{th}}\) level, with \(j \ne n\) , $$\begin{aligned} CNOT_{1,Q_t} = \Big [ S^1_{j,+}\left( \left| {1_j}\right\rangle \left\langle {1_j}\right| + \left| {2_j}\right\rangle \left\langle {2_j}\right| \right) + S^1_{j,-} \left( \left| {0_j}\right\rangle \left\langle {0_j}\right| +\left| {3_j}\right\rangle \left\langle {3_j}\right| \right) \Big ]. \end{aligned}$$ (18) Case 1d: \(Q_c=1\) , \(Q_t\) is odd, and on the \(j{\mathrm{th}}\) - level for \(j \ne n\) , $$\begin{aligned} CNOT_{1,Q_t} = \Big [ S^1_{j,+}\left( \left| {0_j}\right\rangle \left\langle {0_j}\right| + \left| {3_j}\right\rangle \left\langle {3_j}\right| \right) + S^1_{j,-} \left( \left| {1_j}\right\rangle \left\langle {1_j}\right| +\left| {2_j}\right\rangle \left\langle {2_j}\right| \right) \Big ]. \end{aligned}$$ (19) Case 1e: \(Q_t=1\) , for even \(Q_c\) such that \(Q_c\) is on the \(i \mathrm{th}\) -level, and \(i \ne n\) , $$\begin{aligned} CNOT_{Q_c,1} = \Big [ \mathbb {I}\otimes \mathbb {I}\left( \left| {0_i}\right\rangle \left\langle {0_i}\right| + \left| {1_i}\right\rangle \left\langle {1_i}\right| \right) + \sigma _{x}\otimes \mathbb {I}\left( \left| {2_i}\right\rangle \left\langle {2_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \Big ]. \end{aligned}$$ (20) Case 1f: \(Q_t=1\) , for odd \(Q_c\) such that \(Q_c\) is on the \(i \mathrm{th}\) - level and \(i \ne n\) , $$\begin{aligned} CNOT_{Q_c,1} = \Big [ \mathbb {I}\otimes \mathbb {I}\left( \left| {0_i}\right\rangle \left\langle {0_i}\right| + \left| {2_i}\right\rangle \left\langle {2_i}\right| \right) + \sigma _{x}\otimes \mathbb {I}\left( \left| {1_i}\right\rangle \left\langle {1_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \Big ]. \end{aligned}$$ (21) Case 2: \(Q_c\) and \(Q_t\) are on the same level i.e., \(i=j\) . Case 2a: \(Q_c\) is odd and \(Q_t\) is even, $$\begin{aligned} CNOT_{Q_c,Q_t} = \Big [ \mathbb {I}\otimes \mathbb {I}\left( \left| {0_j}\right\rangle \left\langle {0_j}\right| + \left| {1_j}\right\rangle \left\langle {1_j}\right| \right) + S^1_{j,+}S^0_{j,+}\left( \left| {2_j}\right\rangle \left\langle {2_j}\right| \right) + S^1_{j,-}S^0_{j,-} \left( \left| {3_j}\right\rangle \left\langle {3_j}\right| \right) \Big ]. \end{aligned}$$ (22) Case 2b: \(Q_c\) is even and \(Q_t\) is odd, $$\begin{aligned} CNOT_{Q_c,Q_t} = \Big [ \mathbb {I}\otimes \mathbb {I}\left( \left| {0_j}\right\rangle \left\langle {0_j}\right| + \left| {2_j}\right\rangle \left\langle {2_j}\right| \right) +S^1_{j,+}S^0_{j,+}\left( \left| {1_j}\right\rangle \left\langle {1_j}\right| \right) + S^1_{j,-}S^0_{j,-} \left( \left| {3_j}\right\rangle \left\langle {3_j}\right| \right) \Big ]. \end{aligned}$$ (23) Case 3: \(i \ne j\) , where \(Q_c\) and \(Q_t\) are on i th and j th levels, respectively, and \(Q_t \ne N\) if N is even Case 3a: \(Q_c\) is odd and \(Q_t\) is odd, $$\begin{aligned} \begin{aligned} CNOT_{Q_c,Q_t} = \Big [&\mathbb {I}\otimes \mathbb {I}\left( \left| {0_i}\right\rangle \left\langle {0_i}\right| + \left| {2_i}\right\rangle \left\langle {2_i}\right| \right) + S^1_{j,+}S^0_{j,+}\left( \left| {1_i}\right\rangle \left\langle {1_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {0_j}\right\rangle \left\langle {0_j}\right| + \left| {3_j}\right\rangle \left\langle {3_j}\right| \right) \\ +&S^1_{j,-}S^0_{j,-} \left( \left| {1_i}\right\rangle \left\langle {1_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {1_j}\right\rangle \left\langle {1_j}\right| + \left| {2_j}\right\rangle \left\langle {2_j}\right| \right) \Big ]. \end{aligned} \end{aligned}$$ (24) Case 3b: \(Q_c\) is odd and \(Q_t\) is even, $$\begin{aligned} \begin{aligned} CNOT_{Q_c, Q_t} = \Big [&\mathbb {I}\otimes \mathbb {I}\left( \left| {0_i}\right\rangle \left\langle {0_i}\right| + \left| {1_i}\right\rangle \left\langle {1_i}\right| \right) + S^1_{j,+}S^0_{j,+}\left( \left| {2_i}\right\rangle \left\langle {2_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {0_j}\right\rangle \left\langle {0_j}\right| + \left| {3_j}\right\rangle \left\langle {3_j}\right| \right) \\ +&S^1_{j,-}S^0_{j,-} \left( \left| {2_i}\right\rangle \left\langle {2_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {1_j}\right\rangle \left\langle {1_j}\right| + \left| {2_j}\right\rangle \left\langle {2_j}\right| \right) \Big ]. \end{aligned} \end{aligned}$$ (25) Case 3c: \(Q_c\) and \(Q_t\) are both even, $$\begin{aligned} \begin{aligned} CNOT_{Q_c, Q_t} = \Big [&\mathbb {I}\otimes \mathbb {I}\left( \left| {0_i}\right\rangle \left\langle {0_i}\right| + \left| {1_i}\right\rangle \left\langle {1_i}\right| \right) + S^1_{j,+}S^0_{j,+}\left( \left| {2_i}\right\rangle \left\langle {2_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {1_j}\right\rangle \left\langle {1_j}\right| + \left| {2_j}\right\rangle \left\langle {2_j}\right| \right) \\ +&S^1_{j,-}S^0_{j,-} \left( \left| {2_i}\right\rangle \left\langle {2_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {0_j}\right\rangle \left\langle {0_j}\right| + \left| {3_j}\right\rangle \left\langle {3_j}\right| \right) \Big ]. \end{aligned} \end{aligned}$$ (26) Case 3d: \(Q_c\) is even and \(Q_t\) is odd, $$\begin{aligned} \begin{aligned} CNOT_{Q_c, Q_t} = \Big [&\mathbb {I}\otimes \mathbb {I}\left( \left| {0_i}\right\rangle \left\langle {0_i}\right| + \left| {2_i}\right\rangle \left\langle {2_i}\right| \right) + S^1_{j,+}S^0_{j,+}\left( \left| {1_i}\right\rangle \left\langle {1_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {1_j}\right\rangle \left\langle {1_j}\right| + \left| {2_j}\right\rangle \left\langle {2_j}\right| \right) \\ +&S^1_{j,-}S^0_{j,-} \left( \left| {1_i}\right\rangle \left\langle {1_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {0_j}\right\rangle \left\langle {0_j}\right| + \left| {3_j}\right\rangle \left\langle {3_j}\right| \right) \Big ]. \end{aligned} \end{aligned}$$ (27) Case 4: \(i \ne j\) , where \(Q_c\) and \(Q_t\) are on i th and j th level, respectively, and \(Q_t = N\) , for even N Case 4a: \(Q_c\) is even, $$\begin{aligned} \begin{aligned} CNOT_{Q_c,Q_t} = \Big [&\mathbb {I}\otimes \mathbb {I}\left( \left| {0_i}\right\rangle \left\langle {0_i}\right| + \left| {1_i}\right\rangle \left\langle {1_i}\right| \right) + S^1_{j,+}S^0_{j,+}\left( \left| {2_i}\right\rangle \left\langle {2_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {0_j}\right\rangle \left\langle {0_j}\right| \right) \\ +&S^1_{j,-}S^0_{j,-} \left( \left| {2_i}\right\rangle \left\langle {2_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {1_j}\right\rangle \left\langle {1_j}\right| \right) \Big ]. \end{aligned} \end{aligned}$$ (28) Case 4b: \(Q_c\) is odd, $$\begin{aligned} \begin{aligned} CNOT_{Q_c,Q_t} = \Big [&\mathbb {I}\otimes \mathbb {I}\left( \left| {0_i}\right\rangle \left\langle {0_i}\right| + \left| {2_i}\right\rangle \left\langle {2_i}\right| \right) + S^1_{j,+}S^0_{j,+}\left( \left| {1_i}\right\rangle \left\langle {1_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {0_j}\right\rangle \left\langle {0_j}\right| \right) \\ +&S^1_{j,-}S^0_{j,-} \left( \left| {1_i}\right\rangle \left\langle {1_i}\right| + \left| {3_i}\right\rangle \left\langle {3_i}\right| \right) \left( \left| {1_j}\right\rangle \left\langle {1_j}\right| \right) \Big ]. \end{aligned} \end{aligned}$$ (29) based on the two qubit on which CNOT gate is applied, different cases from above can be selected. A different scheme of implementing the universal set of quantum gates on the same quantum walk scaling model is shown in Supplementary information Sec. S1 . This shows that on this model of quantum walk, we can have different forms of the evolution operators to achieve desired operation based on the suitability of the available quantum processors. This above scheme can be very easily implemented on photonic system with different sets of four-sited closed graph. Grover’s search algorithm on three qubit equivalent quantum walk scheme For searching a target state \(\left| {x}\right\rangle\) , Grover’s search algorithm uses an oracle \(\hat{\mathscr {O}}\) on state \(\left| {\Psi }\right\rangle = \sum _{x} \psi _{x} \left| {x}\right\rangle\) of the form, $$\begin{aligned} \widehat{\mathscr {O}}\left| {\Psi }\right\rangle \rightarrow {\left\{ \begin{array}{ll} -\left| {x}\right\rangle &{} \text {, when x is the target element} \\ \left| {x}\right\rangle &{} \text {, else} \end{array}\right. } \end{aligned}$$ (30) Grover’s algorithm requires an oracle for the task of marking the targeted state by applying a negative sign to the desired search result state. The possible states of three-qubit system are \(\left| {000}\right\rangle , \left| {001}\right\rangle , \left| {010}\right\rangle , \left| {011}\right\rangle , \left| {100}\right\rangle , \left| {101}\right\rangle , \left| {110}\right\rangle , \left| {111}\right\rangle\) . On three qubit equivalent quantum walk scheme, we need one real qubit on square lattice (closed graph of four sites). Oracle can be implemented by applying a position dependent evolution operator. The operator involves the coin operation, $$\begin{aligned} \begin{aligned}{} & \hat{N}_{1} =\sigma _{z} \otimes \mathbb {I} \\&\hat{N}_{0} =\hat{C}(0,0,\pi ) \otimes \mathbb {I}\\&\hat{C}(\xi ,\zeta ,\theta )=\begin{bmatrix} e^{i\xi }\cos (\theta ) &{} e^{i\zeta }\sin (\theta )\\ e^{-i\zeta }\sin (\theta ) &{} -e^{-i\xi }\cos (\theta ) \end{bmatrix}. \end{aligned} \end{aligned}$$ (31) and the form of oracle on quantum walk scheme is shown in Fig. 2 . Figure 2 A schematic illustration of the oracle operation on the position state of the three-qubit equivalent quantum walk system using position dependent operators. The states below each square correspond to the target states of Grover’s search. The definition of the various N operators have been defined in Eq. ( 31 ). Full size image Figure 3 A schematic illustration of the iteration operation on the position basis of the three qubit system using position dependent operators. All the states except \(\left| {000}\right\rangle\) will get a negative sign in this one step operation. The definition of the various N operators have been defined in Eq. ( 31 ). Full size image Figure 4 A schematic illustration of the controlled swap gate operation on the position basis of the three qubit equivalent quantum walk system using position dependent operators. The definition of the various A and T operators have been defined in Eq. ( 34 ). Full size image Quantum walk scheme for three qubit Grover’s search algorithm, when the coin and position state is initialized to \(\left| {0}\right\rangle _c \otimes \left| {x=0}\right\rangle\) , involves following steps, 1. A quantum walker starts with an equal superposition of all the states of the form \(\left| {\psi _c}\right\rangle \otimes \left| {x}\right\rangle\) in both coin and position space. It can be achieved by applying operation \(\hat{H}_2 \hat{H}_3\) on position state according to the quantum walk scheme as given in Ref. 37 and then Hadamard operation on coin state. 2. The oracle is applied on the walker according to Fig. 2 to search for the desired marked state. 3. Hadamard operation is again applied on the coin state followed by the operation \(\hat{H}_3 \hat{H}_2\) on position state according to quantum walk scheme. 4. The iteration method can be applied on the walker using position dependent \(\hat{N}\) operators as defined in Eq. ( 31 ) and illustrated in Fig. 3 which will perform a conditional phase shift on every state except \(\left| {000}\right\rangle\) . 5. Again apply Hadamard operation on the coin state followed by the operation \(\hat{H}_3 \hat{H}_2\) on position state according to quantum walk scheme. 6. Repeating steps 2 and 5 (also called the Grover iteration) for less or equal to \(\left\lceil {\frac{\pi }{4}\sqrt{\frac{U}{V}}}\right\rceil\) times where, V = number of target entries in the search space and \(U=2^N\) . For \(N=3\) and \(V=1\) , \(\left\lceil {\frac{\pi }{4}\sqrt{\frac{U}{V}}}\right\rceil\) is \(\le 3 = 2\) . 7. Measurement in coin and position basis will give us our target state. Section S1 of the supplementary file verifies the quantum walk based search algorithm by taking an example on search space of three qubit. Quantum Fourier transformation on three-qubit equivalent quantum walk scheme The quantum Fourier transform is defined on orthonormal basis \(\left| {0}\right\rangle ,\left| {1}\right\rangle \ldots \left| {X-1}\right\rangle\) as a linear operator of the form, $$\begin{aligned} \left| {\alpha }\right\rangle =\frac{1}{\sqrt{X}}\sum _{l=0}^{X-1} e^{2 \pi i\alpha l/X}\left| {l}\right\rangle \end{aligned}$$ (32) It can be transformed into a more easily implementable format as, $$\begin{aligned} \left| {\alpha }\right\rangle&\xrightarrow {} \frac{1}{\sqrt{X}}\sum _{l=0}^{X-1} e^{2 \pi i\alpha l/X}\left| {l}\right\rangle \nonumber \\&\xrightarrow {} \frac{1}{\sqrt{X}}(1\left| {0}\right\rangle +e^{2 \pi i0.\alpha _{N}}\left| {1}\right\rangle )(1\left| {0}\right\rangle +e^{2 \pi i0.\alpha _{N-1} \alpha _{N}}\left| {1}\right\rangle )... (1\left| {0}\right\rangle +e^{2 \pi i0.\alpha _{1}...\alpha _{N-1}\alpha _{N}}\left| {1}\right\rangle )\nonumber \\&{[}e^{2 \pi i \alpha _{1}....\alpha _{N-1}\alpha _{N}}=e^{2 \pi i0.\alpha _{N}}] \end{aligned}$$ (33) where \(X=2^{N}\) and N is the number of qubits in the system. Quantum Fourier transformation on three-qubit quantum walk scheme requires a controlled-SWAP operation which, on quantum walk scheme can be obtained by applying the following operations, $$\begin{aligned} \begin{aligned} \hat{A}^{0}_{+}\left| {k,m}\right\rangle&=\hat{\sigma }_{x}^{m+1}\hat{S}_{1,+}^{0}\left| {k,m}\right\rangle \\ \hat{A}^{1}_{+}\left| {k,m}\right\rangle&=\hat{\sigma }_{x}^{m+1}\hat{S}_{1,+}^{1}\left| {k,m}\right\rangle \\ \hat{A}^{0}_{-}\left| {k,m}\right\rangle&=\hat{\sigma }_{x}^{m-1}\hat{S}_{1,-}^{0}\left| {k,m}\right\rangle \\ \hat{A}^{1}_{-}\left| {k,m}\right\rangle&=\hat{\sigma }_{x}^{m-1}\hat{S}_{1,-}^{1}\left| {k,m}\right\rangle \\ \hat{T}_{+}\left| {k,m}\right\rangle&=\hat{S}_{1,+}^1\hat{S}_{1,+}^1\hat{S}_{1,+}^0\hat{S}_{1,+}^0\left| {k,m}\right\rangle ;\\ \end{aligned} \end{aligned}$$ (34) where \(\hat{S}^{k}_{1,\pm }\) are conditional shift operators in the position space of the walker and are given by Eq. ( 1 ) on the position state \(\left| {m}\right\rangle\) conditioned on the state of coin \(\left| {k}\right\rangle\) and \(\hat{\sigma }^{m}_{x}\) is given by, $$\begin{aligned} \hat{\sigma }^{m}_{x} =\hat{\sigma }_x \otimes (\left| {m}\right\rangle \left\langle {m}\right| )_p+\mathbb {I} \otimes \sum _{j\ne m}(\left| {j}\right\rangle \left\langle {j}\right| ) \end{aligned}$$ (35) Equations ( 35 ) and ( 34 ) and Fig. 4 outlines the operations which swaps two qubits. Thus, quantum Fourier transformation on quantum walk scheme can be given by the operation as shown in Fig. 5 , after producing the initial state, where, $$\begin{aligned} \begin{aligned} {QFT}_{00}&= \hat{A}^{1}_{+} \hat{H}_3 \hat{H}_2 \hat{H}_1 \\ {QFT}_{01}&= \hat{A}^{0}_{-} \hat{H}_3 \hat{H}_2 \hat{P}(\pi /4) \hat{H}_1 \\ {QFT}_{11}&= \hat{A}^{0}_{+} \hat{H}_3 \hat{\Phi }(\pi /2) \hat{H}_2 \hat{P}(\pi /4) \hat{P}(\pi /2) \hat{H}_1 \\ {QFT}_{10}&= \hat{A}^{1}_{-} \hat{H}_3 \hat{H}_2 \hat{\Phi }(\pi /2) \hat{H}_1 \\ \end{aligned} \end{aligned}$$ (36) and operator \(\hat{H}_2,\hat{H}_3\) and \(\hat{P}(\phi ), \hat{\Phi }(\phi )\) on the quantum walk scheme is given in the Ref. 37 . \(\hat{A}^{0}_{+,-}, \hat{A}^{1}_{+,-}\) are given by Eq. ( 34 ) and \(\hat{H}_1\) is Hadamard operation on coin operation. Figure 5 A schematic illustration of quantum Fourier transformation on three-qubit equivalent quantum walk scheme using position dependent operators. Full size image Phase estimation algorithm on three qubit equivalent quantum walk scheme To estimate the phase \(\varphi\) induced by an operator \(\hat{U}\) on one of its eigenvectors \(\left| {\psi }\right\rangle\) using single qubit on three-qubit equivalent quantum walk system, we consider the eigenvector \(\left| {\psi }\right\rangle\) as the coin state and the position Hilbert space represents the state of the control qubits. The quantum circuit for phase estimation on three-qubit system is given in Fig. 6 . Figure 6 Schematic of quantum circuit for phase estimation procedure on three qubit system. The state of the first qubit of the system is equivalent to the coin state and last two qubit shows the equivalence to the position states of the quantum walk scheme. Full size image Algorithm for phase estimation on quantum walk scheme according to quantum circuit as given in Fig. 6 , when coin and position state is initialised to state \(\left| {0}\right\rangle _c \otimes \left| {x=0}\right\rangle\) is, 1. Bringing the position states in equal superposition by implementing Hadamard operation \(H_2\) and \(H_3\) on second and third qubit, respectively. The state after this operation will have form, $$\begin{aligned} \begin{aligned} \left| {\phi _1}\right\rangle&= \left| {0}\right\rangle _c \otimes \frac{\left| {00}\right\rangle +\left| {01}\right\rangle +\left| {10}\right\rangle +\left| {11}\right\rangle }{2} \\&= \left| {0}\right\rangle _c \otimes \frac{\left| {x=0}\right\rangle +\left| {x=1}\right\rangle +\left| {x=3}\right\rangle +\left| {x=2}\right\rangle }{2} \end{aligned} \end{aligned}$$ (37) 2. Bringing the coin state to \(\left| {\psi }\right\rangle _c\) using unitary operation G such that \(\left| {\psi }\right\rangle _c = G \left| {0}\right\rangle _c\) . Here, \(\left| {\psi }\right\rangle _c\) is an eigenvector of the unitary operator U with eigenvalue \(e^{2\pi i \varphi }\) , where the value of \(\varphi\) is unknown. The state after this operation will have form, $$\begin{aligned} \left| {\phi _2}\right\rangle = \left| {\psi }\right\rangle _c \otimes \frac{\left| {0}\right\rangle +\left| {1}\right\rangle +\left| {2}\right\rangle +\left| {3}\right\rangle }{2} \end{aligned}$$ (38) 3. The effect of the controlled \(\hat{U}\) -operations can be thought of as different powers of \(\hat{U}\) being operated on each of the position states as position-dependent coin operation given by, $$\begin{aligned} \begin{aligned} \hat{C}_U'&= \mathbb {I}_C \otimes \left| {0}\right\rangle \left\langle {0}\right| + \hat{U} \otimes \left| {1}\right\rangle \left\langle {1}\right| \\&\quad + \hat{U}^2\otimes \left| {3}\right\rangle \left\langle {3}\right| + U^3\otimes \left| {2}\right\rangle \left\langle {2}\right| . \end{aligned} \end{aligned}$$ (39) The form of the state after this operation is $$\begin{aligned} \begin{aligned} \left| {\phi _3}\right\rangle&= \hat{C}_U' \left| {\phi _2}\right\rangle \\&= \frac{\left| {\psi }\right\rangle \left| {0}\right\rangle +\hat{U}\left| {\psi }\right\rangle \left| {1}\right\rangle +\hat{U}^2\left| {\psi }\right\rangle \left| {3}\right\rangle +\hat{U}^3\left| {\psi }\right\rangle \left| {2}\right\rangle }{2}\\&= \left| {\psi }\right\rangle \otimes \frac{\left| {0}\right\rangle +e^{i\varphi }\left| {1}\right\rangle +e^{2i\varphi }\left| {3}\right\rangle +e^{3i\varphi }\left| {2}\right\rangle }{2} \end{aligned} \end{aligned}$$ (40) 4. Then applying inverse quantum Fourier transformation in the standard basis such that final state is, $$\begin{aligned} \begin{aligned} \left| {\phi _{f}}\right\rangle&= {QFT}^{-1} \left| {\phi _3}\right\rangle \\&=\left| {\psi }\right\rangle \left| {\tilde{\varphi }}\right\rangle \end{aligned} \end{aligned}$$ (41) The position dependent evolution operator for inverse Fourier transformation on state \(\left| {\phi _3}\right\rangle\) in quantum walk scheme is given as, $$\begin{aligned} {QFT}^{-1} = (G \otimes \mathbb {I}) V_{2}^{x} V_{1}^{x} (G^{\dagger } \otimes \mathbb {I}), \end{aligned}$$ (42) where G is the operator given in step-2 of the algorithm and the form of \(V_{1}^{x}\) and \(V_{2}^{x}\) position dependent operator is given as, $$\begin{aligned} \begin{aligned} V_{1}^{x=0}&= \hat{S}_{1}^{+}(\hat{H} \otimes \mathbb {I}) \\ V_{1}^{x=1}&= \hat{S}_{1}^{-}(\hat{H} \otimes \mathbb {I}) \\ V_{1}^{x=3}&= \hat{S}_{1}^{-}(\hat{H} \otimes \mathbb {I}) \\ V_{1}^{x=2}&= \hat{S}_{1}^{+}(\hat{H} \otimes \mathbb {I}) \end{aligned} \end{aligned}$$ (43) and $$\begin{aligned} \begin{aligned} V_{2}^{x=0}&= \hat{S}_{1}^{-}(\hat{H} \otimes \mathbb {I}) \\ V_{2}^{x=1}&= \hat{S}_{1}^{+}(\hat{H} \otimes \mathbb {I}) (\hat{\Phi }_{-\frac{\pi }{2}}\hat{\sigma }_x\otimes \mathbb {I}) \\ V_{2}^{x=3}&= (\hat{\sigma }_x \otimes \mathbb {I}) \hat{S}_{0}^{+}(\hat{H} \otimes \mathbb {I}) \\ V_{2}^{x=2}&= (\hat{\sigma }_x \otimes \mathbb {I}) \hat{S}_{0}^{-}(\hat{H} \otimes \mathbb {I}) (\hat{\Phi }_{\frac{\pi }{2}}\hat{\sigma }_x\hat{\sigma }_z\otimes \mathbb {I}). \end{aligned} \end{aligned}$$ (44) Using this scheme on quantum walk, phase \(\varphi\) induced by an operator \(\hat{U}\) on one of its eigenvectors \(\left| {\psi }\right\rangle _c\) can be estimated upto a certain accuracy. The accuracy in the estimation can be increased by using large position Hilbert space. Quantum space and time complexity An analysis of complexity is mainly concerned with the inherent cost of solving a problem, where the cost is measured in terms of some well-defined resources. In this section, we shall be considering two ways of expressing complexity, namely quantum space complexity and quantum time complexity . We define these terms as follows. 1. Quantum space complexity is defined as the number of real qubits required to implement the circuit. This is analogous to the classical space complexity. 2. Quantum time complexity is defined as the smallest number of time steps required to perform a computation on the circuit. In other words, it describes the least number of simultaneous elementary operations required to perform a single computation on the circuit. This is also in direct analogy to classical time complexity. Note that these definitions are expressed keeping in mind the specific discrete-time quantum walk-based scheme presented in this manuscript. In the circuit model of quantum computation, they are equivalent to the notions of circuit width and depth, respectively. Complex multi-qubit gates can be composed of elementary gates from the universal gate set, and we define the complexity of implementing a (complex) multi-qubit gate as the quantum time-complexity of the equivalent circuit constructed with elementary operations. In case of a standard circuit model, an elementary operation can be a single-qubit Hadamard gate, a single-qubit phase gate, or a two-qubit CNOT operation. Every other gate may be composed of these gates as they form a universal set 35 . In case of our model based on the quantum walk, an elementary operation is defined as a walk operation, i.e. a coin operation, followed by a shift operation. In case multiple quantum walk operations can be done with a common step, then the time complexity reduces. As an example, consider the sequence of steps \(\hat{\Phi }({\frac{\pi }{2}})\hat{P}(\frac{\pi }{4})\hat{P}(\frac{\pi }{2})\) , as used in the definition of \(QFT_{11}\) . With the way that \(\Phi\) and P gates are described in Ref. 37 , all the gates can effectively be implemented by a coin operation, and can thus be combined into a single P operation with a global phase. Thus, the time complexity of this 3 gate sequence is actually 1 time step. Compared to the earlier universal quantum computation scheme with quantum walks 36 , our scheme defines computation purely as a sequence of walks that achieve the same effect as certain gates, instead of actually simulating gates from quantum walk steps, and then creating mirroring the circuit model. The existing models thus impose significant resource requirements to achieve the implementations of algorithms, thereby becoming prohibitively resource-intensive. We now detail an analysis of circuits for implementation of quantum algorithms considered in this paper, both in terms of the standard circuit model and our proposed quantum walk model of computation. Grover’s search In this work, have considered Grover’s search algorithm for 3 qubits, and have searched for the state \(\left| {011}\right\rangle\) as an example. Quantum space complexity The proposed quantum walk model of computation requires 3 qubits for implementation of the walk, however, only one qubit is a real (particle) qubit. The other two qubits are implemented with the position space. Thus, the quantum space complexity is 1. In case of the standard circuit model (Fig. 7 ), the implementation requires 3 qubits for the algorithm, and 1 ancilla qubit, thus making the total quantum space complexity to be 4. Figure 7 Schematic of quantum circuit for implementation of Grover’s search algorithm on a three qubit system. The oracle is designed here to search for the state \(|011\rangle\) . Full size image Quantum time complexity In our quantum walk model, the generation of the initial superposition (done by the operator \(H_2H_3\) ) takes 6 time steps. The oracle operation requires 1 time step, each ensuing Hadamard operation requires 3 time steps, and the final iteration operator needs another 2 time steps. Since 2 Grover iterations are required for a 3-qubit implementation, the total quantum time complexity becomes 39. In the standard circuit, the superposition requires 4 parallel single-qubit gates on all 4 qubits and can be achieved in 1 time step. The various gates required to implement the algorithm on a 3-qubit system are the 4-qubit CCCNOT , which requires the Toffoli ( CCNOT ) gate implementation, the single qubit X gate, and the CCZ gate. The various gates and their quantum time complexities are shown in Figs. 8 , 9 , 10 and 11 . Accounting for everything, the complete implementation has a quantum time complexity of 72. Figure 8 Schematic of quantum circuit for implementation of the CCCNOT gate on a 4-qubit system. This gate has a quantum time complexity of 45. Full size image Figure 9 Schematic of quantum circuit for implementation of the Toffoli gate on a three qubit system. The quantum time complexity of this implementation is 13. Full size image Figure 10 Schematic of quantum circuit for implementation of the Pauli X gate on a single qubit. This gate has a quantum time complexity of 3. Full size image Figure 11 Schematic of quantum circuit for implementation of the CCZ gate on a three qubit system. This implementation is similar to the 3-qubit Toffoli gate, except it has a few less operations. The quantum time complexity of this gate is thus 11. Full size image Quantum Fourier transform We have considered the problem of computing the quantum Fourier transform for a 3-qubit system. Quantum space complexity In our circuit, we require 1 real qubit to achieve a 3-qubit quantum Fourier transform. The standard circuit model requires 3 real qubits. Quantum time complexity In our quantum walk-based model, the operations \(A^{i}_{\pm }\) are essentially a single step of the walk, and can be implemented in one time step. The \(A^{i}_{\pm }\) operation is then followed by the sequence \(H_1H_3H_2\) , which requires 7 time steps to implement. The maximum time is required by \({QFT}_{01}\) and \({QFT}_{11}\) operators each of which require 9 time steps. This is due to the fact that the position-dependent Phase operations may be applied simultaneously, as they are all simply coin operations. Thus, the quantum-walk based model can implement this algorithm in 9 time steps. Figure 12 Schematic for the quantum circuit model implementation of the quantum Fourier transform on a three qubit system. The quantum time complexity of this implementation is 21. Full size image In the standard circuit, the QFT is implemented as shown in Fig. 12 . The circuit begins with a Hadamard gate, followed by two controlled phase gates on the first qubit. The implementation of a controlled phase gate is shown in Fig. 13 . From Fig. 13 , it may be seen that a single controlled phase gate requires 5 time steps to implement. The final gate we require to implement is a two-qubit swap gate, which can be implemented efficiently as a series of 3 two-qubit CNOT gates, which requires 3 time steps to implement. The circuit is shown in Fig. 14 . As a result, the standard circuit will require a total of 21 steps to implement. Figure 13 Schematic for the quantum circuit model implementation of the controlled phase gate on two qubits. The quantum time complexity of this gate is 5. Full size image Figure 14 Schematic for the quantum circuit model implementation of the swap gate on two qubits. The quantum time complexity of this gate is 3. Full size image Phase estimation algorithm We apply the phase estimation algorithm to an unknown unitary operation U . Quantum space complexity In our circuit, we require only 1 real qubit in order to implement phase estimation. In a standard circuit, we need 3 real qubits to implement this algorithm. Quantum time complexity In our circuit, the initial superposition required can be made in 6 time steps by the application of the operator \(H_2H_3\) . 1 time step is then required to implement the operator G , required to bring the coin into the correct state. It is sure that this will require only 1 time step as the coin qubit can be affected by a coin operator and an identity shift operator on the system. The controlled- U operations are then realised as position-dependent operations, which require 3 time steps to implement (assuming U will require 1 step to implement). The inverse Fourier transform on a 2-qubit system requires a worst case time of 7 steps. The complete quantum time complexity of this circuit thus becomes 17. Figure 15 The circuit model of a controlled- U gate, where U is an unknown unitary, as given in Ref. 42 . Here \(P(\phi )\) represents the phase gate as described in 37 , and \(A,B,C,\phi\) satisfy \(e^{i\phi }AXBXC = U\) , and \(ABC=\mathbbm {1}\) . X is the Pauli- X operation. Full size image In a standard circuit as shown in Fig. 6 , the two initial Hadamard gates require one time step to implement, as they can be implemented in parallel. Going by the reduction for a controlled- U gate, as shown in Fig. 15 , the controlled- U and controlled- \(U^2\) gates would require 5 time steps each. The remaining circuit for an inverse QFT on two qubits requires 1 time step each for the Hadamard gates, 5 time steps for the controlled Phase, and 3 time steps for the swap gate. In total, the circuit requires 21 time steps to be implemented. By this analysis, proposed quantum walk scheme uses a lesser number of real qubits to implement algorithmic operations than the circuit model. It also requires a lesser number of time steps than the circuit model in order to implement the algorithms shown here. Single-qubit error detection The proposed model of quantum computation also lends itself to an elementary representation of a quantum encoding. In this section, we present two examples of [3, 1] codes, and an example of a [5, 1] code. The [3, 1] code is able to detect either one of single-qubit errors, namely, bit-flip and phase-flip errors, and the [5, 1] code saturates the quantum Hamming bound, and is thus able to protect against arbitrary single-qubit errors. Bit-flip code The [3, 1] bit-flip encoding and decoding in the circuit model of computation is realised as shown in Fig. 16 . The encoding uses 2 auxiliary qubits to generate error syndromes which can be corrected by the decoding circuit, which is shown post the introduction of error. The decoding of the syndrome and correction of error in a single qubit case requires the implementation of a Toffoli gate as shown. The Toffoli gate may be implemented with the gates belonging to the universal set as shown in Fig. 9 . The equivalent operation on a 3-qubit quantum walk system as detailed in 37 may be performed by the operations \(CNOT_{1,2}\) and \(CNOT_{1,3}\) applied to the system. The final correction step is implemented with the Toffoli gate as demonstrated in Fig. 17 . Phase-flip code The phase flip encoding is also a [3, 1] code, and is able to detect and correct single-qubit phase flip errors. The circuit representation for encoding and decoding in the phase flip code is shown in Fig. 18 . The circuit for the phase flip code is similar to that used for the bit flip encoding, except that it requires an extra Hadamard operation on each qubit after the bit-flip encoding. On a 3-qubit equivalent quantum walk system, this corresponds to applying the operations \(H_1\) , \(H_2\) , and \(H_3\) on the system after applying the bit-flip encoding. Figure 16 A circuit-model representation of the bit-flip code, implemented on a 3-qubit system. The figure is based on from the code as described in 42 . Full size image Figure 17 A possible realization of the bit-flip encoding in the quantum walk paradigm. The figure ( a ) describes the steps in encoding, and ( b ) describes the decoding steps. The quantum time complexity of the complete encoding and decoding scheme is 5 (2 for encoding and 3 for decoding). In the circuit formalism, the quantum time complexity becomes 15 (1 for encoding, 14 for decoding). The reason for this disparity is that the quantum walk formalism allows for a simple realization of the Toffoli gate. Full size image Figure 18 A circuit-model representation of the phase-flip code, implemented on a 3-qubit system. The figure is based on from the code as described in 42 . This circuit is very similar to the bit-flip code, except that it requires an extra Hadamard operation on each qubit during both the detection and correction steps. Full size image Error correcting code Figure 19 shows a circuit model implementation of a [5, 1] encoding, a more elaborate description of which was given by Laflamme et al. 43 . The code enables error correction, and is able to correct against general single-qubit errors. This encoding may be implemented on a 2-level (5-qubit equivalent) graph in a quantum walk system, with one level consisting of a two-site closed graph and the second level being a four-site closed graph. This setup would require 2 real qubits to implement this code, however, in order to reduce the space complexity, it is possible to use a pair of 4-site closed graphs with a single particle executing a discrete time walk on them. Figure 19 The quantum circuit for computing syndromes according to the [5, 1] code described in 43 . The circuit for recovery of the original qubit \(\left| {\phi }\right\rangle\) is exactly the reverse of this circuit. The empty circle for the control qubit implies that the gate is activated if the qubit is in the \(\left| {0}\right\rangle\) state. Gates are applied from the left column to the right column. Gates in a single column may be applied simultaneously. Full size image The quantum walk implementation would also require the implementation of the twin CNOT gate, the controlled-controlled-Z ( CCZ ) gate, and the CCCZ gate with two of the inputs inverted. The circuit model implementation of these gates is shown in Figs. 11 and 20 . The sequence of steps required to achieve the CCZ gate on a quantum walk system is the same as illustrated in 37 . The CCCZ implementation will vary depending on the system topology chosen, however, it is illustrated here considering a 2-level implementation, where the both levels are 4-site graphs, traversed by a single particle. The forms of the operators required are illustrated in detail in “ Implementing hadamard, phase, and controlled-NOT gates on N -qubit equivalent system ". The twin CNOT gate may be designed in both the models in the same way, namely, by applying two CNOT operations simultaneously. Figure 20 A circuit-model realization of the modified CCCZ -gate as required for implementing the [5, 1] quantum error-correcting code. In order to realize the CCCZ -gate which activates as usual, i.e. when all inputs are \(\left| {1}\right\rangle\) , one may substitute the single qubit pauli X rotations executed at the first time step with identity operations in this figure. The method to create this realization has been described in 44 . Full size image The CCCZ -gate requires a modified form of the controlled phase operation, which is given by the operator \(\tilde{P}_{3,j}\) , which will cause a conditional phase to be applied in case the control qubit is in the state \(\left| {0}\right\rangle\) . This is described in Fig. 21 . The form of the complete operation is given by Eq. ( 45 ). $$\begin{aligned} CCCZ_{Q,\bar{b}, \bar{c},d} = \mathbbm {1}_Q \otimes \left( \left| {00}\right\rangle _{j=1} + \left| {10}\right\rangle _{j=1} \right) \otimes \tilde{P}_{3,j=2} + \mathbbm {1}_Q \otimes \left( \left| {01}\right\rangle _{j=1} + \left| {11}\right\rangle _{j=1} \right) \otimes \mathbbm {1}_{j=2}, \end{aligned}$$ (45) where j denotes the level at which the operation is applied, Q is the first qubit in the system (assuming the qubit to be encoded is mapped to the real qubit), and the operation \(\tilde{P}_{3,j=2}\) is as illustrated in Fig. 21 . Figure 21 The modified form of the controlled-phase operation in the quantum walk regime. This operator applies the phase when the control qubit is \(\left| {0}\right\rangle\) . The operation \(\Phi\) adds a global phase, and is defined as described in 37 . Full size image The error correcting codes considered here are based on models of decoherence, as the error on a physical qubit can be modeled as a decoherence-inducing process. Since the proposed scheme uses a single physical system in configuration of position space, the whole computation is a bit less susceptible to errors due to reduced interactions between multiple components of physical systems. Conclusion In this paper, we have presented a more generalized form of the quantum computation using single particle quantum walk 37 , and have shown the scaling of the scheme. Our proposed model can be scaled to system of a higher number of qubits by considering different sets of three-qubit equivalent closed graph as position space. To implement quantum universal gates on larger qubit equivalent system, the coin operation will control the evolution of the walker’s position space by changing the probability amplitude of the targeted closed set. Using appropriate conditional position dependent evolution operators, the quantum walk based quantum computing scheme can be easily implemented. We have also shown that on this scheme on an N -qubit system, universal gate implementation technique is not unique but can be changed according to the available resources. Since quantum walks on closed graph have been experimentally implemented on photonic system before 45 , 46 , with the help of available photonic quantum processors, universal gates model based on single particle quantum walk can be implemented. We have also presented the scheme for implementing quantum algorithms such as Grover’s search, quantum Fourier transform and quantum phase estimation on this scheme for three-qubit equivalent system. A comparison of circuit complexity and circuit depth shows that the proposed quantum walk scheme reduces the complexity when compared to circuit model in all of the cases. However, with a careful designing of position dependent evolution operators one can engineer the implementation of various quantum computational tasks.