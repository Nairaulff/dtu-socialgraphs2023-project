introduction quantum theory reveals interesting counter-intuitive phenomenon even simplest physical system paradigmatic example bell nonlocality einstein-podolsky-rosen epr steering nonlocal phenomenon appear strong correlation outcome spatially separated measurement performed independent observer correlation enable distinguish classical quantum origin experiment recently similar split classical quantum feature found setup closely related quantum communication task so-called prepare-and-measure scenario scenario viewed communication game two party alice sender bob receiver dimension classical versus quantum system communicated alice bob bounded game described follows see panel fig upon receiving input preparation device controlled alice emits physical system quantum state _x\ assume _x\in given d\ge following however focus explicitly d=2\ assume two-dimensional quantum system qubits classical system bit transmitted alice bob state _x\ passed measurement device upon receiving input performs measurement obtains outcome paper focus smallest nontrivial case o=2\ i.e. measurement two outcome case denote outcome b=\pm goal scenario compare quantify performance qubits classical bit scenario discussed extent small number preparation measurement see e.g ref note also emblematic protocol so-called quantum random access code qrac special instance game see ref reference communication protocol related qrac game also found application randomness generation see ref recent notable generalization qrac protocol considered ref however paper would like turn attention case large i.e range see main bottleneck study computation relevant quantity associated classical bit case develop large scale numerical tool paper first concentrate qubit case elaborate classical bit case qubit case define whereas classical bit case define quantity l_2 quantity turn define ratio l_2 upper-bound new constant respectively constant physical meaning defining respective critical white noise tolerance critical detection efficiency binary-outcome measurement qubit prepare-and-measure scenario paper relate two introduced constant purely mathematical grothendieck constant k_g\ generally grothendieck problem implication many area mathematics first major impact theory banach space -algebras recently influenced graph theory computer science see e.g ref furthermore connection grothendieck problem bell nonlocality noticed tsirelson subsequently acin based work tsirelson exploited connection show critical visibility bell nonlocal two-qubit werner state given 1/k_g k_g refined version grothendieck constant relating local bound correlation bell scenario classical bit bound communication scenario find paper new constant equal k_g also introduce constant relate critical detection efficiency crit binary-outcome measurement qubit scenario particular find model finite detection efficiency crit =1/k_ armed efficient numerical tool bound constant implies upper bound 0.6377 crit figure prepare-and-measure setup qubit communication classical model using one bit communication upon receiving input setting alice sends bob qubit quantum state bob performs projective measurement b|\vec 1\hspace -3.30002pt +b\vec two outcome labelled b=\pm result expectation value bob outcome becomes =\vec see classical one bit gisin-gisin protocol follows shared randomness distributed two party unit vector s^2\ chosen uniformly random sphere obtaining setting alice communicates bob classical binary message c=\text sgn bob output b=\text sgn c\vec probability b=0\ probability 1-|\vec finally bob performs coarse graining output grouping b=0\ b=1\ identifying outcome b=1\ result shown section adapting gisin-gisin model scenario expectation value bob b=\pm outcome becomes full size image qubit case qubit binary outcome o=2\ case measurement described two positive operator b|y b=\pm acting ^2\ sum identity b=+1|y +\pi b=-1|y 1\hspace -3.30002pt 1\hspace -3.30002pt denotes 2\times identity matrix statistic experiment given formula aligned b|x b|y aligned important note preparation measurement unknown observer fact dimension transmitted system two since binary outcome b=\ -1\ becomes convenient use expectation value aligned b=+1|x b=-1|x aligned note take value +1\right however hilbert space dimension communicated particle bounded general expectation value +1\right become possible simplest scenario show effect appears already n=3\ m=2\ o=2\ see ref example respect measurement operator b|y one case namely set projective rank-1 measurement particular interest case aligned b|y =\frac 1\hspace -3.30002pt _2+b\vec _y\cdot aligned _y\in s^2\ b=\pm vector hermitian 2\times pauli matrix hand let set aligned 1\hspace -3.30002pt _2+\vec _x\cdot aligned _x\in s^2\ density matrix corresponds pure state bloch vector _x\ note case equation give aligned =\vec _x\cdot aligned _y\in s^2\ limit set possible distribution dimension two captured following expression aligned w=\sum x=1 y=1 aligned coefficient real witness matrix dimension n\times let define quantity aligned =\max x=1 y=1 aligned form maximize expression bob measurement b|y qubit state _x\ thus value achievable general two-dimensional quantum resource setup define quantity aligned =\max x=1 y=1 aligned =\vec _x\cdot _y\ maximize unit vector _x\ _y\ three-dimensional euclidean space turn obtained pure qubit state projective measurement however optimal projective measurement general rank-1 rank-0 rank-2 well indeed example matrix even simple n=m=3\ o=2\ case note corresponds projective qubit measurement rank case =\vec _x\cdot _y\ see yet see set obtained rank-1 projective measurement significant subset set corresponding general qubit measurement tool computing value found ref importantly value serve dimension witness prepare-and-measure scenario indeed witness defined implies set state _x\ x=1 transmitted bob must contained least one state x=x least three dimension qutrit classical bit versus qubit case â€”it turn witness also serve quantumness witness end let discus classical bit case want bound expression alice prepare classical two-dimensional system i.e bit let denote bound l_2 corresponds situation l_2 certifies measurement performed bob true incompatible quantum measurement acting true qubit state mathematically classical bit case equivalent qubit case discussed restriction qubits sent basis measurement bob carried basis want maximize correlation arising classical two-dimensional system maximum attained pure state aligned 1\hspace -3.30002pt _2+a_x\cdot aligned a_x=\pm observables b_y=\pi 0|y -\pi 1|y form aligned aligned _z\ standard pauli matrix aligned array 0\\0 -1\end array aligned b_y^+\ b_y^-\ variable inserting value obtain aligned 1+a_x b_y^++ 1-a_x b_y^- aligned since binary variable a_x=\pm translate =b_y^+\ a_x=1\ =b_y^-\ a_x=-1\ classical one-bit bound l_2 given aligned l_2 =\max x=1 y=1 aligned defined maximize binary variable a_x b^+_y b^-_y\in +1\ word expression corresponds following deterministic protocol alice depending prepares bit a_x=\pm sends bob output b=\pm depending value a_x\ measurement setting bob output deterministic function b=f a_x output assumes b=\pm write aligned l_2 =\max a_x=+1 y=1 b^+_y+\sum a_x=-1 y=1 b^-_y\right aligned maximum taken binary a_x\ b_y^+\ b_y^-\ variable eliminate variable b^+_y\ b^-_y\ expression get following formula l_2 aligned l_2 a_x=\pm a_x=+1 m_x\right\| _1+\left\| a_x=-1 m_x\right\| _1\right aligned consists maximization binary variable a_x=\pm formula m_x\ denotes row real n\times matrix v\vert _1\ denotes manhattan norm real vector i.e. v\vert _1=\sum prove several interesting property l_2 method section property norm particular l_2\ proven matrix norm let recall l_2 key quantity study enables witnessing quantumness preparation quantumness measurement indeed l_2 defined equation certifies incompatible quantum measurement acting true qubit state performed measurement prepared state originate basis section property norm restrict study property l_2\ norm generalize l_2 l_k prove l_k\ norm well moreover l_k monotonic increasing function furthermore section programming tip efficient implementation code give tip efficient implementation branch-and-bound algorithm computing l_k bound k=2\ well introducing constant define two quantity related l_2 defined follows let first introduce case ask maximum ratio l_2 interested value aligned =\max l_2 aligned maximization taken possible real n\times matrix defined l_2 defined let recall grothendieck constant order given aligned k_g =\max aligned maximization taken real matrix arbitrary dimension n\times defined defined follows aligned =\max x=1 y=1 a_xb_y aligned maximum taken a_x b_y\in +1\ value k_g according recent work designolle bounded aligned 1.4367\le k_g 1.4546 aligned lower bound improved version given ref upper bound improved version given ref see ref historical data best lower upper bound k_g prove =k_g given result section proof relation interested well quantity similar define quantity follows aligned =\max l_2 aligned aligned =\sum x=1 ^n\sum y=1 aligned note relation aligned l_2 l_2 aligned whenever l_2 also note l_2 therefore =k_g immediately obtain lower bound 1.4367\ paper give efficient large-scale numerical method obtain even better lower bound quantity namely prove lower bound 1.5682\ also prove upper bound quantity putting together following interval aligned 1.5682\le aligned constant open problem close least reduce gap lower upper limit next present result section contains main finding three subsection result proof relation =k_g prove claim relate l_2 m'\ given following matrix see also aligned m'=\left array m\\-m\end array aligned real n\times matrix denote m_x\ -th row matrix note according definition m'\ size 2n\times m'\ row m'_x=m_x\ x+n =-m_ x=1 following lemma hold lemma 2.1 l_2 =2l matrix m'\ form l_2\ l_2\ norm given definition local bound given proof lemma given method section -norm -norm special family matrix need prove following lemma lemma 2.2 k_g arbitrary matrix l_2 proved method section property norm lemma follows definition next lemma read lemma 2.3 k_g proof prove suffices show arbitrary real matrix exists matrix m'\ defined =2q l_2 =2l first relation follows special structure m'\ second relation shown lemma 2.1 therefore k_g prof claim corollary 2.4 corollary lemma 2.2 2.3 obtain =k_g hence bound 1.4367\le 1.4546\ k_g see corollary matrix m'\ size 48\times 24\ indeed construction based matrix size 24\times 24\ provides best knowledge smallest matrix property 48-by-24 matrix m'\ follows hand =\sqrt already attained 2\times matrix chsh-form aligned array 1\\1 -1\end array aligned remains open question show matrix size smaller 48\times 24\ might use different construction one proof bound 1.5682\le upper bound first prove upper bound translating gisin-gisin model bell nonlocality scenario find following statistic obtained scenario bit classical communication aligned =\frac aligned s^2\ denotes preparation vector s^2\ denotes measurement bloch vector give proof formula method section adapting gisin-gisin model scenario show panel fig description classical one-bit model one hand due gisin-gisin one-bit model arbitrary n\times matrix aligned x=1 y=1 l_2 aligned form maximized unit vector _x\ _y\ three-dimensional euclidean space hand substituting formula find aligned x=1 y=1 _x\cdot 1\right aligned maximization unit vector _x\ _y\ three-dimensional euclidean space also used definition definition comparing right-hand side aligned l_2 aligned left-hand side prof upper bound lower bound following prove lower bound using large-scale numerical tool note however resulting bound rigorous particular final result due exact computation step follows given fixed setup alice bloch vector _x\ bob bloch vector _y\ method following define n\times -dimensional one-parameter family matrix entry aligned =\eta 1-\eta aligned =\vec _x\cdot _y\ wish show 0,1\right distribution scenario simulated one bit classical communication fact due expectation value gisin-gisin model enough consider interval 1/2,1\right show quantumness therefore need find matrix certain size n\times given 1/2,1\right aligned x=1 ^n\sum y=1 l_2 aligned defined l_2 defined problem i.e. finding suitable smallest possible solved modified version original gilbert algorithm popular collision detection method used example video game industry algorithm iterative procedure adapted problem given section modified gilbert algorithm adapted scenario indeed using algorithm gilbert find value aligned =0.6377 aligned corresponding 70\times 70\ matrix form satisfies inequality give technical detail input parameter implementation algorithm section parameter implementation gilbert algorithm rearranging making use equation find bound aligned l_2 aligned due definition lower bound aligned 1/\eta 1.5682 aligned follows physical meaning constant role scenario value interesting physical point view well since related critical noise resistance experimental setup transmitted _x\ noisy fully depolarizing channel 1-p_ crit =1- 1/k_ give amount 1-p_ crit critical white noise 1\hspace -3.30002pt experiment rank-1 projective qubit measurement maximally tolerate still able detect quantumness namely fully depolarizing channel visibility parameter qubits _x\ emitted alice turn p\rho _x+ 1-p 1\hspace -3.30002pt expectation value becomes aligned =p\vec _x\cdot aligned _x\ _x\ bloch vector alice qubits whereas _y\ _y\ bloch vector bob measurement witness quantumness must exist expectation value matrix arbitrary size aligned l_2 aligned inserting making use obtain aligned crit =\min _m\frac l_2 =\frac =\frac k_g aligned critical noise tolerance fact value k_g appears study bell nonlocality two-qubit werner state note recent approach ref based simulability werner state local model yield relation crit 1/k_g upper lower bound following bound amount 1-p_ crit critical white noise follow aligned 0.3039\le 1-p_ crit 0.3125 aligned role scenario section proof bound 1.5682â‰¤ proved lower bound 1.5682\ prove bound related finite detection efficiency threshold bob measurement end assume bob detector perfect fire probability assume measurement fails detect bob output b_y=1\ due possible relabelings loss generality assume probability detection problem symmetric detection efficiency review problem bell scenario found ref hand problem scenario elaborated ref upper bound 1/\sqrt critical value symmetric detection efficiency found since doe depend expectation value becomes =\eta 1-\eta hence witness matrix detects quantumness finite detection efficiency assuming optimal preparation state measurement whenever aligned 1-\eta l_2 aligned recalling =\sum solving relation optimizing witness matrix obtain critical detection efficiency crit aligned crit =\min l_2 =\frac aligned defined particular using lower bound value 1.5682\ obtain improved upper bound 0.6377 crit noted however general detection efficiency model rather outputting b_y=1\ bob output third result could potentially give lower detection efficiency threshold open problem whether third outcome lower detection efficiency threshold also assumed bob qubit measurement rank-1 projector achieve however known true qubit maximum larger given hence say general symmetric detection efficiency threshold upper bounded 1/k_ open problem whether upper bound tight let mention two-outcome scenario different type modelling loss event due finite detection efficiency also imagined namely let assume bob associate outcome +1\ -1\ no-detection event equal probability case expectation value =\eta 1-\eta outcome +1\ assigned no-detection event becomes lead modified inequality l_2 modified critical detection efficiency crit =\min l_2 =1/k_ therefore using bob non-deterministic assignment outcome no-detection event critical detection efficiency linked k_g =k_ i.e. grothendieck constant order note however due finding k_g critical detection efficiency non-deterministic modelling no-detection event suboptimal compared deterministic assignment model associate no-detection event given outcome method property l_2\ l_k\ norm notation first introduce notation used throughout subsection let a^n set dimensional vector set let v_i\ denote element a^n\ let a^n a^m n+m denote concatenation vector let singleton element a^0\ let a^1\ parenthesis may omitted ^3\ example let ... a^n\ write instead inferred context define set real n\times matrix matrix represented vector row vector i.e ^n\ let m^\top transposition let denote m\times identity matrix convenient define set matrix whose row exactly one let denote set permutation matrix let m\right\| i=1 m_i\right\| _1\ denote manhattan norm matrix definition l_k\ .â€”we first give definition l_k\ let aligned aligned l_k l_k w^\top m\right\| aligned aligned note defined notation w^\top\ denotes transposed matrix prove corresponds case k=2\ proof follows aligned a_x\in a_x=+1 m_x\right\| a_x=-1 m_x\right\| _1\right w\in w^\top _1m\right\| _1+ w^\top _2m\right\| _1\right w\in w^\top m\right\| _1\\ l_2 aligned property l_k\ .â€”we prove several interesting property l_k\ note focus main text k=2\ however general case k\ge interest sake moreover also motivated physically corresponding classical communication beyond bit first prove l_k\ norm k\ge end prove homogeneity positive definiteness subadditivity property lemma 3.1 l_k\ norm homogeneity aligned l_k w^\top _1\\ w^\top m\right\| _1\\ w^\top m\right\| _1\\ aligned denotes absolute value scalar l_k\ defined positive definiteness aligned l_k 0\\ w^\top m\right\| 0\\ w^\top m\right\| 0\\ w^\top m_i aligned triangle inequality aligned l_k m+n w^\top m+n _1\\ w^\top m\right\| w^\top n\right\| _1\right w^\top m\right\| w^\top n\right\| _1\\ l_k l_k aligned let define follows aligned +1\ vm\right\| aligned definition consistent one given local classical bound correlation bell inequality defined correlation matrix quantity also appears computer science literature name -quadratic programming let note recently efficient computation proposed ref along code first prove basic property l_2 next prove l_k k+1 k\ge bound l_k value multiplied however know whether bound saturated lemma stating first claim follows lemma 3.2 aligned l_2 aligned proof given following chain equation plus single inequality invoked fourth line aligned +1\ vm\right\| _1\\ +1\ m\right\| _1\\ w^\top _1m w^\top _2m\right\| _1\\ w^\top _1m\right\| w^\top _2m\right\| w^\top m\right\| _1\\ l_2 aligned next lemma prof l_k monotone increasing lemma 3.3 aligned l_k k+1 aligned proof given following chain aligned l_k w^\top m\right\| _1\\ i=1 w^\top m\right _i\right\| _1\\ i=1 w^\top m\right _i\right\| m\right\| _1\right i=1 k+1 w^\top m\right _i\right\| _1\\ w^\top m\right\| _1\\ k+1 w^\top m\right\| _1\\ k+1 aligned finally prove upper bound l_k lemma read follows lemma 3.4 aligned l_k aligned proof aligned l_k =\max w^\top m\right\| _1\\ i=1 w^\top _i\right\| _1\\ i=1 w^\top _im\right\| _1\\ i=1 2w^\top m\right\| _1\\ i=1 2w^\top m\right\| m\right\| _1\right i=1 i=1 aligned arrive sixth line invoked definition open question whether lemma 3.4 tight however find family matrix k\ge ratio l_k tends infinity increasing formally lemma 3.5 exists matrix aligned l_k aligned proof based explicit construction matrix m^k\ defined ref see also ref proof let m^k\in k-1 family matrix aligned m^k_ k-i-1 aligned example aligned m^4 array rrrrrrrr 1\\ -1\\ -1\\ -1\end array aligned explicit calculation find aligned m^k l_k m^k k\left array k-1\\ k-1 array k2^ k-1 aligned note particular case k=2\ matrix chsh expression case =2\ l_2 =4\ hence k=2\ upper bound lemma 3.4 tight conjecture bound tight greater value finally show l_2\ general l_k\ behaves concatenation two matrix defined aligned array a\\ b\end array aligned lemma 3.6 let a\in b\in aligned l_k l_k l_k aligned proof aligned l_k i+j w^\top _1\\ t\in ^\top _1\\ t\in s^\top t^\top b\right\| _1\\ t\in s^\top a\right\| t^\top b\right\| _1\right s^\top a\right\| t\in t^\top b\right\| _1\\ l_k l_k aligned note l_k l_k doe hold general example let aligned array 1\\ -1\end array aligned aligned array 0\end array aligned explicit calculation obtain aligned l_2 l_2 aligned finally shown l_k\ relates cut norm matrix norm introduced frieze kannan ref see also several application graph theory norm defined follows aligned =\max x=1 y=1 a_xb_y aligned maximum taken a_x b_y\in 0,1\ note similarity definition norm equivalent shown related follows aligned aligned using relation along lemma 3.4 find aligned l_k 4kc aligned special case l_2\ following lower upper bound aligned l_2 aligned generalization l_k\ norm generalize norm l_k f_m\ extension prove key property branch-and-bound implementation l_k\ algorithm first define following function definition 3.7 aligned aligned f_m f_m n-i ^\top m\right\| aligned aligned word f_m maximum w^\top m\right\| _1\ prefix f_m\ considered generalization l_k following lemma introduces key property made use branch-and-bound method lemma 3.8 aligned p^\top m\right\| l_k aligned proof aligned n-i ^\top _1\\ n-i p^\top w^\top _1\\ n-i p^\top a\right\| w^\top b\right\| _1\right p^\top a\right\| n-i w^\top b\right\| _1\\ p^\top a\right\| l_k aligned let give following definition generalizing f_m definition 3.9 aligned f_m f_m aligned computation f_m\ optimized big enough value f_m return without computing f_m expressed following lemma lemma 3.10 aligned f_m array p^\top m\right\| c\right p^\top a\right\| l_k f_m f_m otherwise array aligned proof given split three case case aligned f_m n-n ^\top m\right\| c\right ^\top m\right\| c\right p^\top m\right\| c\right aligned case aligned p^\top a\right\| l_k c\\ f_m f_m c\\ f_m aligned case aligned f_m n-i ^\top m\right\| c\right s\in w\in n-i-1 ^\top m\right\| c\right n-i-1 ^\top m\right\| c\right f_m f_m f_m ... f_m f_m aligned last lemma subsection read lemma 3.11 aligned l_k f_m aligned proved follows aligned f_m ^\top m\right\| 0\right w^\top m\right\| _1\\ l_k aligned programming tip efficient implementation l_2\ l_k\ code subsection give programming tip branch-and-bound implementation exact computation l_k k\ge k=2\ k=3\ algorithm even faster l_k\ solver general due specialization detail first remind reader notation defined section property norm haskell code downloaded github instruction installing using code including parallel execution using guessed result also found branch-and-bound calculation l_k\ norm l_k k\ge calculated using following definition following lemma definition 3.12 0\le i\le let aligned f_m f_m array p^\top m\right\| p^\top a\right\| l_k f_m f_m otherwise. array aligned function f_m\ recursively call larger larger prefix prefix size reach middle case conditional exit recursion speed computation crucially lemma 3.13 aligned l_k f_m aligned reducing cost sharing sub-calculations â€”in definition 3.12 expensive calculation l_k p^\top m\right\| _1\ p^\top a\right\| _1\ show reduce cost calculation cost l_k reduced memoizing previously computed l_k\ value table v_1 v_2 v_3 v_n l_k depends l_k v_i i+1 v_n note l_k v_i i+1 v_n depends l_k v_j j+1 v_n i+1 i+2 take account dependency correct order calculating l_k\ value l_k v_n l_k n-1 v_n l_k n-2 n-1 v_n ... l_k v_2 v_3 v_n option skip p^\top a\right\| l_k test large matrix mean l_k calculated trade-off miss opportunity exiting recursion experience skipping test 3n/4 result 2\times\ speedup cost calculating p^\top a\right\| _1\ a\in note aligned ^\top p^\top q^\top aligned p^\top already computed time ^\top needed cost p^\top a\right\| _1\ reduced cost p^\top reduced way implies considerable speedup example calculation l_2 made nearly time faster optimization cost p^\top a\right\| _1\ reduced caching previously calculated manhattan norm row matrix p^\top reducing cost symmetry â€”for s\in permutation matrix aligned w^\top m\right\| ^\top m\right\| aligned cost l_2\ halved follows let aligned array 1\\ 0\end array aligned ^\top m\right\| ^\top m\right\| _1\ follows f_m f_m mean skip calculation f_m thus l_2 f_m i.e. start calculation non-empty prefix save work harnessing general l_k\ case bit complex first define set canonical prefix prefix i_1 i_2 i_j canonical first occurrence number index i_1 i_2 i_j\ sequence example prefix _3\ canonical _2\ non-canonical prefix exists permutation canonical f_m f_m mean enough examine canonical prefix compute l_k\ parallel concurrent execution â€”for parallel execution one use following equation aligned f_m i\in f_m aligned used p\in parallel depth fine-tuning execution different architecture higher depth better core parallel execution may miss opportunity exiting recursion communication thread best known l_k\ value certain point time therefore implemented concurrent execution thread share best known l_k\ value reducing cost guessed l_k\ value â€”optionally computation sped providing guessed l_k value user value used instead guessed value may lower l_k higher guessed value better unless guessed value higher l_k case f_m\ return guessed value compared result f_m\ witness maximal w^\top m\right\| _1\ value able detect whether guessed value high -norm l_2\ -norm special family matrix m'\ relate l_2 m'\ given following matrix aligned m'=\begin pmatrix pmatrix aligned matrix size n\times arbitrary real entry note m'\ size 2n\times m'\ row m'_x=m_x\ x+m =-m_ x=1 following lemma hold lemma 3.14 l_2 =2l matrix m'\ form l_2\ l_2\ norm given definition local bound given note l_k\ defined case k=2\ corresponds definition l_2\ proof fix matrix dimension n\times specifies m'\ virtue let a_x\in -1,1\ x=1 b_y\in -1,1\ y=1 optimal vector giving note value unique general different optimal configuration may exist however choose one optimal vector a_x\ b_y\ choose x+n =-a_x\ x=1 b_y^+=b_y^-=b_y\ y=1 value obtain lower bound l_2 l_2 show upper bound l_2 implies l_2 =2l contradiction lemma assume l_2 a_x\ vector corresponding l_2 value property x+m =-a_x\ exists least one call x'\ a_x'=a_ x'+n suppose one x'\ proof multiple x'\ index a_x'=a_ x'+n similar formula l_2 two row x'\ x'+n\ question appear within norm either first second norm depending whether a_x'=a_ x'+n take value +1\ -1\ however case cancel norm question result two row m'\ eliminated one matrix one matrix -m\ however matrix one row eliminated local bound greater applies matrix removed several row therefore l_2 true either thus arrived contradiction adapting gisin-gisin model scenario adapt lhv model ref exploit finite efficiency detector reproduce quantum correlation singlet state exactly show lhv model ref adapted communication scenario produce expectation value aligned b=+1|\vec b=-1|\vec =\frac aligned s^2\ denotes preparation bloch vector s^2\ denotes measurement bloch vector first show outcome b=\pm giving expectation value aligned b=+1|\vec b=-1|\vec =\vec aligned obtained probability 1/2 b=0\ outcome probability 1/2 coarse-graining distribution grouping b=0\ outcome b=+1\ obtain expectation value classical model using one bit classical communication alice bob follows protocol alice bob share classical variable form unit vector chosen uniformly random unit sphere s^2\ alice alice sends binary message c=\text sgn bob c=+1\ c=-1\ bob bob output b=\text sgn c\vec probability corresponding detection event b=\pm bob output b=0\ probability 1-|\vec corresponding non-detection event claim follows protocol yield correlation =\vec reproduces correlation probability 1/2 return b=0\ case proof â€”we need calculate expectation value b=+1|\vec b=-1|\vec according protocol detection event b=\pm given aligned =\int s^2 d\vec sgn sgn aligned conditional density probability distribution choosing given detection event either output b=+1\ b=-1\ function calculated aligned =\frac b=\pm b=\pm aligned detection efficiency b=\pm probability detection failure 1-\eta b=0 value given aligned b=\pm =\int s^2 d\vec 4\pi aligned stated protocol give density probability distribution b=\pm 4\pi inserting value give 2\pi turn inserted obtain integral aligned =\frac 2\pi s^2 d\vec sgn aligned integral calculated using spherical symmetry particular one choose w.l.o.g vector aligned 0,0,1 aligned ref obtain aligned =\cos =\vec aligned probability 1/2 wanted prove modified gilbert algorithm adapted scenario given 1/2,1\right correlation matrix defined algorithm yield following matrix satisfying aligned x=1 ^n\sum y=1 l_2 aligned algorithm input number preparation number measurement setting define setup unit vector _x\ x=1 ^n\ i.e. bloch vector alice prepared state b_y y=1 ^m\ i.e. bloch vector bob projective rank-1 measurement n\times -dimensional matrix given entry value max define stopping criterion output matrix size n\times set i=0\ set n\times zero matrix given matrix matrix run heuristic oracle maximizes overlap -e_ det deterministic one-bit correlation det description heuristic see-saw oracle given section lower bound using see-saw iterative algorithm denote point det returned oracle det find convex combination i+1 det minimizes distance -e_ let denote distance dist let i=i+1\ step dist i=i_ max return matrix coordinate =e_ -e_ note dist decreasing function since maximizing overlap -e_ det deterministic one-bit correlation vector np-hard problem step use heuristic method describe section lower bound using see-saw iterative algorithm hand description exact branch-and-bound type algorithm found section programming tip efficient implementation code use exact method generally time-consuming see-saw method check output matrix satisfies condition chosen parameter true implies lower bound 1/\eta proved section proof bound 1.5682 also noted branch-and-bound-type algorithm much faster brute force algorithm implemented algorithm using parallelism found multi-core desktop computer solve problem range n=m=70\ day brute force algorithm limited n=m=40\ setting parameter implementation gilbert algorithm specify explicit parameter used obtain lower bound 1.5682\ three-dimensional unit sphere choose vector _x\ x=1 ^n\ _y\ y=1 ^m\ equal _i=\vec _i\ i=1 n=m=70\ unit vector chosen define optimal packing configuration grassmannian space downloaded neil sloane database advantage type packing point antipodal point located far apart possible three-dimensional unit sphere implemented modified gilbert algorithm section modified gilbert algorithm adapted scenario matlab without memory buffer see detail memory buffer ref case using memory buffer step modified algorithm instead calculating convex combination point det see section modified gilbert algorithm adapted scenario compute convex combination point det i-j j=0 m-1\ size memory buffer explicit computation use buffer size m=40\ stopping condition k=2\times 10^5\ =0.665\ detail performance modification found ref step gilbert algorithm oracle see-saw heuristic described section lower bound using see-saw iterative algorithm obtain good typically tight lower bound l_2 hand used branch-and-bound-type algorithm described section programming tip efficient implementation code calculate l_2 exactly integer algorithm implemented haskell see github site downloadable version matlab file eta_70.m also downloaded github located subdirectory l2_eta_70 give detailed result input parameter particular give unit vector _i=\vec _i=\vec _i\ lower bound _x\cdot _y=\sum _x\cdot _y\ value l_2 input matrix placed subdirectory l2_eta_70 name w70i.txt running time gilbert algorithm section modified gilbert algorithm adapted scenario implemented matlab one week note however computation time spent oracle see-saw part described section lower bound using see-saw iterative algorithm hand haskell code compute exact l_2 value 70\times 70\ witness matrix took hour run workstation using physical core memory usage computation negligible matlab eta_70.m routine defines 70\times 70\ matrix give =\vec _i=\vec _i\ unit vector sloane database i=1 ,70\ note integer multiplying output matrix gilbert algorithm truncating non-integer part calculation yield =\sum =194369\ =\sum _x\cdot _y\simeq 5.3672235\times 10^5\ hand branch-and-bound-type haskell code give exact value l_2 =412667\ matched see-saw search section lower bound using see-saw iterative algorithm number obtain aligned l_2 =1.5682+\varepsilon aligned 1/k_ =0.6377-\varepsilon upper bound critical detection efficiency crit small positive number lower bound l_2 using see-saw iterative algorithm give iterative algorithm based see-saw heuristic compute l_2 algorithm form oracle part step gilbert algorithm described section modified gilbert algorithm adapted scenario algorithm input integer matrix size n\times output lower bound l_2 l_2 defined formula let l_2 choose random assignment a_x a_x\ random element vector size element binary value set sgn sgn denotes modified sign function sgn =+1\ x\ge -1\ otherwise let transpose set sgn let transpose form column vector s^+=mb^+\ size form column vector s^-=mb^-\ size form column vector s=\max s^+ s^- size s_x=\max s_x^+ s_x^- x=1 form -valued column vector follows let a_x=+1\ s_x^+\ge s_x^-\ otherwise let a_x=-1\ x=1 let l_2=\sum x=1 s_x\ new vector return point repeat algorithm two value l_2\ equal two consecutive iteration note iteration step objective value l_2 guaranteed decrease therefore output algorithm heuristic lower bound exact value l_2 discussion tested quantumness two-dimensional system prepare-and-measure scenario preparation binary-outcome measurement setting fall well range one-qubit scenario two-level system transmitted sender receiver setup real n\times matrix defines coefficient linear witness denote l_2 exact value one-bit bound associated matrix found efficient numerical algorithm computing l_2 bound exceeded detect quantumness prepared qubits quantumness i.e incompatibility measurement introduced new constant related grothendieck constant order large-scale tool crucial efficient bounding l_2 hence bounding constant relate new constant white noise resistance prepared qubits critical detection efficiency measurement performed large matrix given two algorithm computing l_2 simple iterative see-saw-type algorithm branch-and-bound-type algorithm former heuristic algorithm usually give tight lower bound l_2 however sometimes fails find exact value l_2 happens often size matrix get larger larger contrast latter branch-and-bound-type algorithm give exact value l_2 used compute l_2 matrix size large 70\times 70\ application algorithm established bound 1.5682\le new constant upper bound crit 0.6377\ critical detection efficiency qubit measurement scenario