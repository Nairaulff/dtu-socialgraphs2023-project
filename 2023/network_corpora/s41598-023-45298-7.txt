introduction given hamiltonian inverse temperature qite task evolving quantum state according non-unitary propagator -\beta qite central ground-state optimisation also partition-function estimation quantum gibbs-state sampling i.e task preparing thermal quantum state tunable inverse temperature fundamentally relevant useful notable algorithmic application instance even though approximating ground state generic hamiltonians expected efficient even quantum computer—as solve qma-complete problem significant speed-ups classical simulation possible motivated several ground-state cooling algorithm without qite especially combinatorial optimisation molecular electronic structure hand gibbs-state sampler used main sub-routines quantum semi-definite program solver training quantum machine-learning model e.g moreover qite also enables quantization metts lanczos algorithm directly simulate certain thermal property without gibbs-state sampling quantum gibbs state approximated quantum metropolis markov-chains variational circuit trained minimise free energy e.g however former involve deep complex circuit whereas latter highly limited variational ansatz turn heuristic qite algorithm ground-state optimisation exist one simulates pure-state qite unitary circuit depends input state hamitonian small- step one determine circuit measurement input state step classical post-processing one possibility optimise variational circuit measured data limited expressivity ansatz another possibility invert linear system generated measurement size system well number measurement required exponential number qubits unless restrictive locality assumption made figure high-level schematic algorithm qite primitive system register carry input state whereas ancillary register initialised computational-basis state unitary transformation composed sequence v_k\ gate applied ancillas measured gate make one query hamiltonian oracle shown specific choice gate sequence conditioned detecting ancillas desired state output controllable error refer circuit generating qite primitive master qite algorithm post-selection probability—given approximately p_\psi =\left\| —can decrease fast hence high probabilistic approach based repeat-until-success fail vast majority trial turn coherent approach based quantum amplitude amplification provide close-to-quadratic runtime speed-up expense enormous circuit depth contrast introduce master algorithm concatenates qite fragment inverse temperature _l\ l\in l\in _l=\beta\ l\in fragment successively run probabilistically success probability significantly higher query complexity significantly lower entire evolution run end yielding enormous saving overall runtime even beating coherent approach high time preserving practical advantage probabilistic approach experimental implementation full size image general guaranteed-precision qite algorithm based unitary circuit followed ancillary-qubit post-selection circuits—to refer qite primitive —are efficient well target precision however due intrinsically probabilistic post-selection must applied multiple time refer master qite algorithm —to obtain deterministic output repeat-until-success master algorithm apply primitive parallel i.e independent probabilistic run thereby inducing increase circuit depth however overall complexity inversely proportional post-selection probability instead coherent master algorithm based amplitude amplification close-to-quadratically smaller overall complexity however require enormous circuit depth significantly ancillas addition fundamental efficiency limit generic qite algorithm known overview introduce two efficient qite primitive based quantum signal processing qsp framework well practical master qite algorithm see fig prove universal lower bound complexity qite primitive seen imaginary-time counterpart fast-forwarding theorem rte first primitive designed hamiltonians given well-known block-encoding oracle model whereas second one simplified model real-time evolution oracle involving single time primitive feature excellent query complexity number oracle call ancillary-qubit overhead fact first primitive complexity sub-additive tolerated error scaling saturates universal bound hence primitive optimal regime interestingly turn crucial master algorithm contrast primitive complexity multiplicative requires single ancilla throughout oracle significantly fewer gate appealing intermediate-scale quantum hardware turn master qite algorithm break evolution small- fragment run fragment primitive probabilistically surprisingly yield overall runtime competitive relevant regime high even better coherent approach time preserving advantage probabilistic one experimental feasibility finally complexity master algorithm depends fragmentation schedule i.e number fragment relative size one hand primitive rigorously prove critical inverse temperature n/2 runtime lower coherent qite shown explicitly constructing schedule r=2\ fragment job remarkably hand fragmented qite outperforms coherent qite also observed primitive extensive numerical evidence precisely study overall runtime function n=15\ qubits numerically-optimized schedule experiment involve random instance hamiltonians encoding four computationally hard class problem ising model associated maxcut weighted maxcut problem iii restricted quantum boltzmann machine transverse-field ising model quantum generalization fully-connected heisenberg model sherrington-kirkpatrick model spin glass see clear trend whereby n/2 fragmentation outperforms coherent qite primitive optimal number fragment r\lesssim obtained value imply algorithm outperforms coherent qite computationally hardest range particularly relevant hamiltonians exponentially small spectral gap moreover impressively advantage attained cost circuit depth number ancillas identical probabilistic qite worth noting although prove fragmented qite outperform coherent algorithm doe mean scaling better see supplementary material sec vii result consider -qubit system hilbert space denote hilbert space ancillary register first discus primitive universal complexity lower bound master algorithm last formal definition proof theorem found method quantum imaginary-time evolution primitive use notation -qite-primitive refer circuit implement block-encoding qite propagator i.e unitary f_\beta acting containing -approximation f_\beta one matrix block 0\le subnormalization factor f_\beta =e^ -\beta h-\lambda min min minimal eigenvalue applied state primitive approximatelly produce target state system postselecting ancillas postselection success probability given =\alpha ^2\ ^2\ trace-distance error output-state spectral error primitive sec introduce two qite primitive posse basic structure shown fig sequence gate v_k\ generates approximate block-encoding f_\beta circuit act system block-encoding ancillas one extra qubit ancilla approximation consists truncating expansion exponential function finite order gate v_k\ make one call oracle inverse contains parameterized single qubit rotation parameter gate determined function expansion using quantum signal processing conceptually two primitive differ kind expansion type oracle circuit description given method especially fig first primitive implement chebyshev expansion using block-encoding oracle o_1\ i.e unitary one block denoted o_1 ancillary-register size o_1 gate complexity o_1\ method prove following theorem qite primitive using chebyshev approximation block-encoding oracle given circuit ',1 -qite-primitive using aligned +\frac 1/\varepsilon e+2\ln 1/\varepsilon aligned query o_1\ o_1^\dagger\ o_1 total ancillary qubits gate complexity p_1 o_1 o_1 per query moreover classical run-time calculate gate p_1\ poly q_1 nice feature sub-additivity 1/\varepsilon note qite primitive obtained work oracle model complexity upper-bounded e^2\ 2/\varepsilon 4/\varepsilon asymptotically better underperforms 8\ln 4/\varepsilon particular tends zero bound ref tends 1/\varepsilon interestingly strict upper bound obtain method expression within modest factor moreover sec numerically verify expression valid bound extra factor even low importantly section cooling-speed limit oracle-based qite algorithm show approach optimal scaling decrease relative 1/\varepsilon stress latter regime crucial master algorithm section fragmented master qite algorithm whose first fragment require precisely low inverse temperature high precision turn opposite regime high preliminary numerical observation suggest asymptotic scaling exact value q_1\ could actually good q_1 1/\varepsilon i.e similar second primitive implement fourier expansion assuming access unitary oracle o_2\ gate complexity o_2 contains time evolution -iht time t=\frac 1+\frac method prove following theorem qite primitive using fourier approximation single real-time evolution oracle given -qite-primitive =e^ -\beta 1+\lambda min -\gamma aligned 4/\varepsilon aligned query o_2\ o_2^\dagger\ ancilla p_2 =g_ o_2 gate per query moreover gate p_2\ obtained classical runtime poly q_2 shown method also hide modest global factor contrast relation 1/\varepsilon multiplicative however return p_2\ requires _2|=1\ ancillary qubit throughout remarkably drastic reduction relative block-encoded oracle algorithm also algorithm based real-time evolution latter due use single real-time instead error-dependent number fact _2|=1\ minimum possible since f_\beta non-unitary least ancilla needed block-encode moreover scaling p_2 optimal since based real-time evolution oracle requires qubitization consequently add small constant number gate per query intrinsic gate complexity o_2 oracle feature make p_2\ specially well-suited near-term device importantly rather peculiarity p_2\ favourable scaling p_2 generic feature type operator-function design behind optimised fourier-approximation algorithm arbitrary analytical real function hermitian operator algorithm support min -1,1 p_2\ reflected sub-normalization factor -\beta 1+\lambda min decrease min departs -1\ turn factor -\gamma arises gibbs phenomenon fourier series theorem hold allowing one trade success probability query complexity optimal value depends coherent probabilistic algorithm sec iii finally theorem straightforwardly extended realistic case approximate oracle sec show generic analytical operator function suffices take oracle error deviation ideal oracle '_o=o '/q keep primitive error cooling-speed limit oracle-based qite algorithm challenging application qite involve small post-selection probability decreasing exponentially worst case effort reduce overall complexity see fueled long race improve going seminal poly 1/\varepsilon recent 2\max e^2\ 2/\varepsilon 4/\varepsilon additive scaling however knowledge runtime limit qite simulation established contrast real-time evolution rte fundamental runtime lower bound given no-fast-forwarding theorem saturated optimal rte algorithm derive analogous bound imaginary time call cooling-speed limit allusion use qite cool system ground state precisely prove universal efficiency limit qite primitive based block-encoded oracle convenient directly applies primitive lowest query complexity i.e p_1\ theorem imaginary-time no-fast-forwarding theorem let -qite-primitive querying block-encoding hamiltonian oracle query complexity least unique solution equation aligned 1-e^ -\frac aligned even though bound given implicitly interesting conclusion readily drawn first fixed left-hand-side decrease monotonically therefore uniqueness solution second fixed grows monotonically third important approximated =2\ '/\alpha\ taylor expansion show latter equation known explicit solution =1\ given hence tends optimal scaling note equivalent first term much smaller second term turn implies exponentially small thus p_1\ close optimal small inverse temperature high precision interestingly regime first fragment master algorithm operate see next fragmented master qite algorithm call master qite algorithm procedure incorporates primitive attain deterministic qite mean algorithm deterministically produce state trace-distance error given input state two variant master qite algorithm reported probabilistic coherent see fig former leverage repeat-until-success apply independent system getting desired output every time postselection ancillas successful resulting system state discarded system ancillas reinitialized new trial average number trial one get one success given 1/p_ contrast latter based quantum amplitude amplification incorporated unitary amplification engine sequentially applied system 1/p_ time hence overall query complexity variant given unified expression aligned q_\kappa aligned prob/coh probabilistic coherent scheme respectively prob =1\ coh =1/2\ =\varepsilon since decrease exponentially quadratic advantage 1/p_ coherent approach highly significant however coherent algorithm circuit depth 1/p_ time greater probabilistic one require extra ancillas make coherent scheme impractical intermediate-scale quantum device master algorithm relies basic identity f_\beta =\prod l=1 partition evolution r\in fragment inverse temperature s_r=\ l\in l\in _l=\beta\ refer s_r\ fragmentation schedule algorithm repeat success -qite-primitive output state l-1 l-1 -th step _l\ given ancillas successfully post-selected state system output state input l+1 -th fragment else algorithm start first fragment =|\psi l-1 prepared -th fragment run alternatively measurement fragment seen monitoring correct block applied l-1 contrast single error detection probabilistic master algorithm see fig note total number trial i.e preparation coincides number repetition first fragment also note method resembles discrete formulation zeno effect applied quantization metropolis-hastings walk classical hamiltonians however apply rewind technique i.e iterate two consecutive step inverse temperature instead rebooting case failure postselection rewind applied fragmented qite would produce right output state following pseudocode summarizes algorithm algorithm fragmented qite full size image correctness complexity algorithm established following theorem proven suplementary material sec theorem fragmented master qite algorithm aligned '_l\le array k=1 ^r\alpha 2\times r-1 l=1 k=l ^r\alpha r-l+1 l-1 array aligned l\in algorithm master qite algorithm error average query complexity aligned s_r =\sum l=1 n_l\ aligned n_l=\frac l-1 k=l ^r\alpha ^2_k average number time run _0=0\ _l=\sum k=1 _k\ l\in =\vert ^2\ figure intuition behind complexity reduction fragmentation overall complexity probabilistic master algorithm dominated area yellow rectangle contrast corresponding complexity fragmented algorithm exemplary case r=3\ fragment dominated area blue-shaded rectangle logarithmic correction precision cumulative width blue-shaded rectangle coincides width yellow one order contrast height yellow rectangle order 1/p_ height blue-shaded one decrease order 1/p_ till order r-1 making blue-shaded area smaller yellow one high-enough reduction strong complexity fragmented algorithm reach even coherent algorithm represented area pink rectangle height 1/\sqrt intuition rigorously proven primitive theorem numerically verified exhaustion primitive section fragmented quantum gibbs-state sampler full size image note primitive average total number trial coincides probabilistic algorithm n_1=1/p_ prob see method important probabilistic algorithm consumes q_1 query per trial successful contrast fragmented one consumes per trial q_1 query plus q_1 query first post-selection succeeds plus q_1 query second one succeeds hence total waste query lower fragmentation see fig strength reduction depends fast n_l\ decrease case get drastic increase largest reduction expected hardest regime maximize effect one wish q_1 decrease fast possible note implies l+1 play latter wish however fortunately q_1 grows approximately linearly _l\ sub-logarithmically 1/\varepsilon _l\ hence sufficiently high one make q_1 arbitrarily smaller q_1 l+1 l+1 choosing _l\ sufficiently smaller l+1 based heuristic next prove primitive algorithm outperform probabilistic algorithm also—for sufficiently high —even coherent one surprisingly proof constructive devise suitable schedule give desired advantage fragmentation remarkably enough consider r=2\ fragment result valid mild assumption success probability function denote inverse function simplicity state theorem explicitly restricted case non-degenerate unique ground state min overlap ^2=|\langle min however straightforwardly generalized degenerate case redefining ^2\ overlap lowest-energy subspace theorem fragmented qite outperforms coherent qite let min unique ground state 1/2.2\ define critical inverse temperature _c=\frac +p^ 2.2 1/4 exists two-fragment schedule s_2\ p_1\ hold s_2 coh _c\ particular s_2=\big _1= _\psi e+2\ln _2=\beta -\delta _1\big valid choice schedule proof given supplementary information sec schedule constructed sole purpose proving existence _c\ general therefore necessarily optimal specific instance sec viii study gibbs-state sampling i.e maximally-mixed state input =2^ -n/2 describing non-interacting particle closed-form expression obtained simple case theorem yield _c= n/2 n\big however section fragmented quantum gibbs-state sampler numerically optimize schedule obtain _c= n/2 hard-to-simulate interacting system proof exploit additive dependence logarithmic term extension multiplicative case left future work nevertheless consistently observe advantage fragmented qite coherent one p_2\ precisely section fragmented quantum gibbs-state sampler numerically find also p_2\ doe fragmentation outperform coherent-qite gibbs-state sampling _c\ scaling p_1\ somewhat larger pre-factor expectable give exponential dependance n_l\ worsens performance either way fragmentation outperform quantum amplitude amplification remarkable since latter requires circuit 1/p_ time deeper ancillas former finding would little practical relevance unphysically high fortunately n/2 intermediate regime useful important application e.g. ground-state cooling generally gibbs-state sampling low temperature requires scaling inversely proportionally spectral gap exponentially small even relatively simple hamiltonians transverse-field ising model fact section fragmented quantum gibbs-state sampler compare inverse temperature 0.9 needed modest ground-state fidelity 0.9 systematically observe either greater close 0.9 evidencing relevance regime advantage fragmented coherent qite finally mentioned p_1\ particularly well-suited fragmentation one hand display _l=1\ l\in hand importantly q_1\ becomes optimal decrease relative 1/\varepsilon convenient minimize first fragment specially first one operate precisely low _l\ _l\ close optimality regime latter verified analytically non-interacting case sec viii numerically example section fragmented quantum gibbs-state sampler sec consistently observe _1\ typically tinny fraction 1/\varepsilon colloquially speaking width first blue-shaded rectangle fig reduced p_1\ primitive figure runtimes circuit depth quantum gibbs-state sampler running primitive versus inverse temperature red corresponds probabilistic master qite algorithm green coherent one blue fragmented one uniform schedule best f.u fragmented uniform orange fragmented one schedule best f.nu fragmented non-uniform see also fig three class hamiltonians shown expression upper panel lattice geometry lower one solid curve represent mean random instance class whereas shaded area corresponding standard deviation example shown correspond n=12\ qubits tolerated error =10^ qualitatively identical behavior observed well =10^ =10^ upper panel average overall query complexity fragmented algorithm comfortably outperform probabilistic one already small addition fragmentation non-uniform schedule outperforms even coherent qite critical inverse temperature _c\ black gray vertical dashed line mark respectively value aver 0.9 hard 0.9 average fidelity ground state instance 10\ smallest gap reach modest value 0.9 shown third panel lie beyond range shown see sec first second panel aver 0.9 smaller _\text complexity fragmented qite aver 0.9 already significantly smaller probabilistic qite consideration imply fragmented qite either competitive directly superior coherent qite range highly relevant ground state preparation e.g advantage fragmentation becomes evident compare average query depth lower panel defined maximum number query per circuit run i.e. taking account independent trial query depth quantifies circuit depth relative depth per query required one successful run full size image fragmented quantum gibbs-state sampler benchmark performance algorithm quantum gibbs-state sampling comparing four class spin-1/2 system ising model associated maxcut weighted maxcut problem iii transverse-field ising interaction restricted-boltzmann-machine rbm geometry heisenberg all-to-all interaction corresponding quantum generalization sherrington-kirkpatrick model spin glass four class feature long-range frustation classically simulating gibbs state random instance computationally-hard task gibbs state =\frac -\beta h-\lambda min =\text -\beta h-\lambda min partition function prepared qite maximally-mixed state _0=\frac =2^ hence post-selection probability =\alpha ^2\ =1\ p_1\ -\beta 1+\lambda min -\gamma p_2\ together determine overall query complexity respect p_1\ p_2\ respectively three master algorithm probabilistic prob coherent coh fragmented technically rather use ceiling function guarantee fragment query complexity integer qubits draw random within class fair comparison re-scale min =-1\ max =1\ calculate complexity =0.1\ 0.01 0.001 partition function evaluated exact diagonalization evaluating requires addition choice schedule propose aligned =\left\ ^a-\left l-1 ^a\right l\in aligned _l=\big l\in guarantee allows control strength inequality varying problem instance sweep value find optimal broyden-fletcher-goldfarb-shanno bfgs algorithm minimizing figure critical inverse temperature p_1\ versus number qubits error hamiltonian class fig except maxcut defined weighted maxcut random 0,1\ blue dot represent mean instance class whereas dashed orange curve fit ansatz =a\ fit result together root-mean-square deviation rmsds shown inset similar scaling observed p_2\ suplementary material sec case n/2 satisfied full size image figure optimal fragmentation schedule primitive versus inverse temperature system size n=5\ blue n=10\ orange n=15\ green solid curve represent mean random weighted-maxcut hamiltonians whereas thickness shaded curve standard deviation tolerated error =10^ qualitatively identical behavior observed well =10^ =10^ hold hamiltonian class fig upper panel show optimal number fragment uniform schedule r,1 central lower panel respectively show optimal non-uniform schedule dashed dotted curve upper lower panel respectively represent fit ansätze =a\ =a\ fit result shown inset remarkably non-uniform schedule observed scaling constant also full size image overall complexity circuit depth obtained together uniform schedule i.e fixed a=1\ shown fig p_1\ scaling fig similar scaling critical inverse temperature obtained p_2\ somewhat higher constant pre-factors see sec expectable due non-unit sub-normalization factor _k\ n_l\ summarizing numerical experiment support following observation observation gibbs-state sampling fragmented qite let primitive fixed type either p_1\ p_2\ every studied exists n/2 schedule s_r=s_r make s_r coh moreover maximal circuit depth required fragmentation asymptotically probabilistic qite apart notable fact fragmentation outperforms coherent qite primitive also remarkable long s_r reach coh s_r already much smaller prob crucially advantage fragmented qite come cost circuit depth since query depth fragmentation l=1 observed almost coincide repeat success specially high note latter need case strictly speaking neither q_1\ q_2\ additive _l\ due non-linear dependance _l\ _l\ course optimal schedule function priori unknown nevertheless trend observe schedule proposal compelling provide sound basis educated guess general observation optimal schedule uniform non-uniform schedule r,1 given overall complexity p_1\ respectively minimised 1/2 =\big 1/3 see fig whereas p_2\ r=2\ =\big 1/6 see sec expected exponential dependence slow growth observed minimize s_r indeed seen p_1\ uniform schedule fig upper panel hand p_2\ uniform schedule r=2\ observed minimize s_r resulting complexity doe reach coh scanned domain 0\le 10000\ however p_1\ fig central panel p_2\ non-uniform schedule fragmentation doe outperform amplitude amplification observed scaling constant remarkably turn grows implies _l\ decrease relative l+1 grows consistent intuition section fragmented master qite algorithm _l\ smaller l+1 addition consistently observe obtained optimal schedule _1\ tinny fraction around 0.1 8\ln 4/\varepsilon see sec fact primitive inserting obtained one see _l\ except last one _r\ also decrease absolute term grows yet grows slowly guarantee _l\ decrease much precisely comparing see '_l\ l\in important sanity check '_l\ identity operator would readily provide '_l,1 -block-encoding hence rendering obtained scaling meaningless discussion presented two qite primitive master qite algorithm first primitive designed block-encoding hamiltonian oracle query complexity number oracle call sub-additive inverse-temperature error scaling better previously-known bound 8\ln becomes provably optimal optimality proven showing saturation universal cooling-speed limit imaginary-time counterpart celebrated fast-forwarding theorem real-time simulation open question optimal scaling away saturation regime coincidentally first step master algorithm operate precisely regime hand second primitive designed simplified model real-time evolution oracle involving single time complexity multiplicative requires single ancillary qubit throughout oracle experimentally-friendlier previous qite primitive interestingly preliminary numerical analysis suggests asymptotic scaling primitive complexity could actually significantly better analytical bound p_1\ even reaching level good q_1 1/\varepsilon primitive based two technical contribution quantum signal processing qsp relevant first one bound approximation error hermitian-operator function truncated chebyshev series analytical real function second one novel fourier-based qsp variant real-time evolution oracle superior previous one requires single real time therefore single ancilla instead multiple one moreover also experimentally friendly requires qubitization primitive technicality aside main conceptual contribution work master qite algorithm conceptually simple yet surprisingly powerful based breaking evolution small- fragment give large reduction wasted query circuit depth yielding overall runtime competitive high even better coherent approach based quantum amplitude amplification qaa remarkable since latter requires general extra ancillary qubits circuit 1/\sqrt time deeper former put perspective illustrative compare quantum amplitude estimation qae standard form qae similar hardware requirement qaa however recently interesting algorithm appeared perform partial qae circuit depth interpolate probabilistic coherent case contrast beat full qaa using circuit depth run much lower bare probabilistic approach fragmented qite outperforms coherent qite proven rigorously primitive also supported exhaustive numerical evidence primitive namely numerical experiment address random instance ising transverse-field ising heisenberg-like hamiltonians encoding computationally hard problem relevant combinatorial optimisation generative machine learning statistical physic e.g emphasize analysis based analytical upper bound query complexity obtained instead complexity corresponding analysis actual numerically obtained query complexity requires re-optimizing fragmentation schedule preliminary observation direction promising indicating actual overall complexity may order magnitude lower fig e.g case qualitatively similar interplay fragmentation qaa expected even type primitive beyond qite whose complexity post-selection probability similar scaling exciting prospect explored future work finding open new research direction towards mid-term high-precision quantum algorithm particular presented primitive cooling-speed limit qsp method master algorithm constitute powerful toolbox quantum signal processor specially relevant transition nisq early prototype fault-tolerant hardware method preliminary consider -qubit system hilbert space qite respect hamiltonian imaginary time -i\ represented non-unitary operator -\beta simulated via post-selection unitary operator encodes -\beta one matrix block denote hilbert space ancillary register _\mathcal joint hilbert space spectral norm operator following formalizes encoding definition block encoding sub-normalization 0\le tolerated error unitary operator u_a\ _\mathcal -block-encoding linear operator a-\langle 0|\ u_a\ =0\ 0,1 use short-hand term perfect -block-encoding perfect block-encoding respectively e.g. u_a\ perfect -block-encoding measuring u_a|\psi _\mathcal leaf state a|\psi a|\psi probability outcome ^2\left\| a|\psi note since u_a =1\ perfect -block-encoding possible a\right\| hence allows one encode matrix even norm greater typically however one wish high possible avoid unnecessary reduction post-selection probability algorithm admit two type oracle input first one based perfect block-encodings therefore requires h\right\| h\right\| however required normalisation enforced simple spectrum rescaling precisely arbitrary lower upper bound respectively minimal maximal eigenvalue min max rescaled hamiltonian =\frac fulfils construction short-hand notation =\frac +\lambda =\frac -\lambda correspondingly rescaling inverse temperature =\delta one obtains propagator -\beta induces physical transformation -\beta hence without loss generality assume throughout h\right\| i.e -1\le min max good position define first oracle o_1\ basis first primitive p_1\ denote entire ancillary register needed p_1\ o_1 specific ancillary qubits required implement o_1\ definition block-encoding hamiltonian oracle refer block-encoding oracle hamiltonian controlled unitary operator o_1\ o_1 form o_1=u_h\otimes 0|+\mathbbm identity operator computational basis control qubit u_h\ perfect block encoding powerful oracle paradigm used qite real-time evolution encompasses e.g. hamiltonians given linear combination unitaries -sparse hamiltonians i.e non-null matrix entry per row hamiltonians given state complexity depends highly efficient implementation known e.g. linear combination unitaries one requiring two-qubit gate o_1\ implemented o_1 ancillary qubits gate complexity i.e total number two-qubit gate o_1 c+\log second oracle model consider encodes real-time unitary evolution generates definition real-time evolution hamiltonian oracle refer real-time evolution oracle hamiltonian time t\in controlled- -ith gate o_2=\mathbbm 0|+e^ -ith 1|\ simplified version model e.g controlled real-time evolution multiple time required thus involving multiple ancillas contrast o_2\ involves single real time ancillary register o_2 consists o_2 single qubit control fact show ancilla needed second primitive p_2\ i.e o_2 advantageous near-term implementation one may instance apply product formula implement o_2\ gate complexity o_2 intermediate-scale system considerably smaller o_1\ furthermore oracle also relevant hybrid analogue-digital platform qsp scheme already studied qite algorithm based post-selection rely unitary quantum circuit simulate block encoding qite propagator refer circuit qite primitive definition qite primitive let -qite-primitive query complexity circuit call oracle inverse generates -block-encoding =e^ -\beta h-\lambda min note hamiltonian agnostic i.e admits provided properly encoded corresponding oracle factor -\beta min implies =1\ thus maximizing post-selection probability however min unknown one replace suitable lower bound -1\ introduces constant sub-normalisation turn query complexity gold-standard figure merit efficiency oracle-based algorithm quantifies runtime relative oracle query fact time-efficient query complexity gate complexity per query g_p\ poly ,1/\varepsilon importantly normalisation cause post-selection probability input state propagate onto error output state making latter general greater exact dependence dictated however =p_ =\alpha ^2\ ^2\ output-state error sup mat sec standing asymptotically upper-bounded turn primitive must incorporated master algorithm formaly define definition master qite algorithm given -qite-primitives querying oracle hamiltonian -master-qite-algorithm procedure output state trace-distance error unit probability overall query complexity sum query complexity applied quantum signal processing quantum signal processing qsp powerful method obtain ^\prime\ -approximate block encoding operator function =\sum eigenvectors eigenvalue hamiltonian query oracle note qsp also extended non-hermitian operator restrict hermitian case simplicity present two qsp method general function one oracle model defs qite primitive obtained particularizing method case =f_ =e^ -\beta h-\lambda min real-variable function design single-qubit rotation start reviewing approximate function one real variable single-qubit pulse single-qubit qsp method consider single qubit rotation r_1 =e^ i\theta i\phi first third pauli matrix respectively 0,2\pi angle -\pi signal processed rotation i\theta called iterate one show given q\in even sequence angle =\big q+1 q+1 sequence rotation _1\left =e^ i\phi q+1 k=1 q/2 r_1 -\theta r_1 2k-1 matrix representation computational basis aligned _1\left =\left array array aligned polynomial complex coefficient determined _1\ target real polynomial wish find generates either real imaginary part respectively done iff satisfy aligned +\sin ^2\theta aligned form aligned aligned =\sum k=0 q/2 b_k\cos 2k\theta =\sum k=1 q/2 2k\theta aligned aligned b_k\in d_k\in alternatively also expressed term chebyshev polynomial first =\cos k\theta second =\sin k+1 kind used obtain either chebyshev fourier series target operator function target expansion satisfies angle computed classically time poly single-qubit qsp method method inspired construction ref shown detail companying paper fundamental gate r_2 =e^ i\frac +\eta -i\varphi i\frac -\eta i\omega -i\kappa five adjustable parameter ^5\ x\in play role signal iterate ref observed gate sequence =\prod k=0 r_2 _q\ q+1 _2=\ q+1 encode certain finite fourier series matrix component formally proven target series unitary operator built one matrix element also provide explicit efficient recipe finding adequate choice pulse _2\ content following lemma lemma single-qubit fourier series synthesis given =\sum m=-q/2 q/2 c_m\ q\in even exist _2\ 0|\ iff moreover _0=0\ _k= ^k/2\ 1\le k\le _2\ calculated classically c_m\ time poly operator-function design block-encoded oracle synthesize -block-encoding query oracle defenition algorithm seen variant single-ancilla method ref slightly different pulse basic idea design circuit p_1\ generates perfect block-encoding target chebyshev expansion =\sum q/2 k=0 b_k t_k _\text -approximates 0\le _\text done adjusting _1\ section quantum signal processing note achievability condition requires guarantee 1+\varepsilon _\text however easily accounted introducing inoffensive sub-normalization 1+\varepsilon _\text see e.g. lemma ref neglect throughout choosing _q\ truncated chebyshev series truncation error _\text obtain desired block-encoding analytical error fulfills aligned _\text min max q/2+1 q/2+1 aligned q/2+1 q/2+1 -th derivative allows one obtain truncation order chebyshev coefficient b_k\ 0\le k\le q/2 see sec xiii one calculate required _1\ see sec xiv next explicitly show generate using short-hand notation =|\lambda o_1 defenition one writes o_1|0_ =\lambda +\sqrt 1-\lambda =0\ defines 2-dimensional subspace _\lambda =\text span exploit single-qubit formalism section quantum signal processing one need iterate act rotation within _\lambda\ general o_1\ appropriate due leakage _\lambda\ repeated application o_1\ however simple oracle transformation—qubitization—that map o_1\ another block-encoding o'_1\ desired property transformed oracle read aligned o'_1 =\bigoplus -i\theta _\lambda _\lambda aligned _\lambda =\cos y_\lambda although qubit resemblance could considered direct analogy qsp single qubit lead strict class achievable function resort one additional qubit single-ancilla qsp extra ancilla control action oracle o'_1\ iterate aligned =\mathbbm +|+o'_1\otimes aligned eigenstates pauli operator qsp qubit ancilla throughout section identity operator o_1 denotes single-qubit hadamard gate let define operator =v_ i\phi =v_ ^\dagger i\phi given phase 0,2\pi play role previous sub-section _\lambda\ playing role operator phase iterated generate aligned =w_ q-1 aligned ancilla pre- post-processing unitaries =\mathbbm i\phi q+1 respectively single-qubit hadamard matrix resulting circuit p_1\ depicted fig following pseudocode give entire procedure algorithm operator-function design block-encoded hamiltonian oracle full size image figure qsp primitive generic operator function design circuit p_1\ algorithm p_2\ algorithm structure ancillas initialised post-selected circuit prepares system state -approximates target output detail specific p_1\ p_2\ respectively shown panel fixed ancillary unitaries single-qubit hadamard gate basic block v_k\ panel represent gate involves one query qubitized oracle o'_1\ turn requires one query o_1\ one inverse _1\ sup mat fig whereas involves one query oracle o_2\ _k\ defined v_k\ o_1^ substituting o'_1\ o_2^ substituting o_2\ hence query complexity p_1\ p_2\ respectively approximating function _q\ determined angle =\big q+1 _2=\ rotation r_z 2\phi =e^ i\phi r_y 2\kappa =e^ i\kappa zyz =r_z _k+\eta r_y 2\varphi r_z _k-\eta _k=\ _k\ p_1\ p_2\ angle chosen _q\ high-precision chebyshev fourier approximation respectively full size image correctness complexity algorithm addressed following lemma proven sec xvi lemma let o_1\ _1\ input algorithm s.t _\text greater exists _1\in q+1 ^\prime\ -block-encoding circuit p_1\ generating requires single-qubit ancilla query o_1\ _1\ p_1 o_1 o_1 gate per query o_1 gate complexity o_1\ furthermore classical runtime calculation _1\ within complexity poly q/2 final comment input function place restriction analytical needed determine truncation order fact evaluate equation exactly one need general closed-form expression however required truncation order given advance corresponding chebyshev coefficient obtained q/2+1\ evaluation specific point node chebyshev polynomial case closed-form expression required classical oracle evaluating suffices moreover important note satisfactory chebyshev approximation guaranteed exist bounded continuous function chebyshev expansion given step algorithm obviously skipped required note algorithm also applied even non-continuous function restricted domain without discontinuity instance case inverse function well-approximated sub-domain -\delta pseudo-inverse polynomial -dependent degree qite-primitive block-encoding oracle qite primitive corresponds output algorithm =f_ =e^ -\beta -\lambda min chebyshev coefficient readily obtained jacobi–anger expansion aligned -\beta =i_ +2\sum k=1 aligned modified bessel function proof theorem thus follows straightforwardly lemma proof theorem function min max 0,1 =e^ -\beta -\lambda min min max satisfies assumption lemma hence input f=f_ algorithm output ^\prime -qite-primitive corresponding truncation error q'=q/2\ aligned _\text q'+1 q'+1 q'+1 e\beta q'+1 q'+1 aligned stirling inequality invoked assumed e\beta q'\ note also first inequality also obtained explicit summation using property bessel function imposing ^\prime\ solving q'\ give query complexity primitive based jacobi–anger expansion give chebyshev-polynomial series exponential function synthesized quantum signal processing see section quantum signal processing expansion applied real-time evolution even qite propagator partition function estimation however algorithm performs statistical simulation based post-processing hence simulate qite state particular used gibbs-state sampling e.g moreover query complexity 1/\varepsilon worse contains extra term lack denominator second term traditionally truncation error expansion bounded using property bessel function contrast use generic upper bound lemma method arbitrary hermitian-operator function give bound exponential hold analytical real function hence useful general remark query complexity _1\ solution q'\ satisfying ^\prime\ given ref based upperbounds q'\ two regime 1/\varepsilon shown q'\le e^2\beta hand applies q'\le 4\ln 1/\varepsilon e+2\ln 1/\varepsilon e\beta 1/\varepsilon therefore aligned q=2q'\le 8\left e\beta +\frac 1/\varepsilon e+2\ln 1/\varepsilon e\beta aligned valid upperbound query complexity consequently muliplicative factor implied notation known modestly equal operator function design real-time evolution oracle synthesize ^\prime -block-encoding oracle defenition proceed section quantum signal processing circuit p_2\ generating perfect block-encoding target fourier expansion =\sum m=-q/2 q/2 c_m imht -approximates suitable done adjusting _2\ according lemma function _q\ fourier approximation intermediary function =\alpha chosen =\lambda interval convergence _q\ min max reason intermediary step circumvent well-known gibbs phenomenon virtue convergence fourier expansion general guaranteed boundary turn sub-normalization factor arises _q\ converges whereas lemma requires force one sub-normalize expansion guarantee normalization entire domain section quantum signal processing inoffensive sub-normalization factor 1+\varepsilon _\text neglected precisely employ see ref construction ref given power series -approximates give c_m\ q/2 _q\ -approximates -\pi aligned q\ge 2\pi aligned analytical one obtain power series truncated taylor series using =\alpha truncation order obtained remainder aligned _\text min max l+1 l+1 aligned turn condition min max -1,1 -\pi lead natural choice t=\pi render _q\ periodic period 2\pi\ addition ref sub-normalization constant bounded term obtained taylor coefficient a_l\ 0\le l\le suffices take aligned l=0 ^l\big 1-2\ ^l\big aligned note inter-dependent one way determine increase iteratively adapt satisfied alternatively expansion converges sufficiently fast e.g. l\rightarrow l+1 a_l 1-\frac 2\delta one simply substitute indeed case qite primitive substitution introduces slight increase unnecessary sub-normalization make resulting independent thus simplifying analysis obtained one finally calculate required _2\ next explicitly show generate iterate taken simply oracle o_2=\mathbbm 0|+ -iht 1|\ notice contrast o_1\ o_2\ readily act rotation 2-dimensional subspace span relaxes need qubitization basic qsp block unitary operator =w_ q-1 aligned =\left i\frac _k+\eta -i\varphi i\frac _k-\eta o_2 -i\kappa aligned 21a aligned =\left i\frac _k+\eta -i\varphi i\frac _k-\eta o_2^\dagger -i\kappa aligned 21b _k\ play similar role r_2 section quantum signal processing x_\lambda\ inside o_2\ playing role take aligned =\mathbbm i\frac _0+\eta -i\varphi i\frac _0-\eta -i\kappa aligned =\mathbbm circuit depicted fig following pseudocode present entire procedure algorithm operator-function design real-time evolution hamiltonian oracle full size image correctness complexity algorithm addressed following lemma proved ref lemma let o_2\ o_2^\dagger\ input algorithm satisfying satisfying exists _2\in q+1 ^\prime -block-encoding circuit p_2\ generating requires query o_2\ o_2^\dagger\ 4+g_ o_2 gate per query o_2 gate complexity o_2\ moreover classical runtime within complexity poly q/2 clearly suitable power series a-priori available analyticity required step algorithm skipped finally note always possible avoid sub-normalization introducing periodic extension readily normalized entire domain fourier expansion however longer valid one must ass query complexity case-by-case basis instance tackled numerically variationally optimising gate sequence block-encode periodic extension either way clearly normalized fourier expansion a-priori available one skip step algorithm qite-primitive real-time evolution oracle qite primitive output algorithm f=f_ proof theorem thus follows straight lemma proof theorem function f_\beta min max 0,1 =e^ -\beta -\lambda min satisfies assumption lemma given min max l+1 l+1 taylor coefficient a_l=\frac min -\beta l\in obtain note l=0 1-\frac 2\delta ^l|\le l=0 1-\frac 2\delta ^l|= min 1-2\delta hence take =e^ -\beta min +\frac 1-2\delta introducing =-\beta +\frac 1-2\delta =\frac re-write =e^ -\beta 1+\lambda min -\gamma allows specify -\gamma instead fourier convergence interval i.e subordinate desired done fixing =\frac 1+\frac together lead fact 4/\epsilon upper-bound query complexity _2\ inferred word multiplicative factor implied notation actually known equal traditional master qite algorithm average number time qite primitive applied probabilistic coherent master qite algorithm 1/p_ 1/\sqrt respectively see fig conveniently 1/p_ approximated practical expression 1/p_ error follows taylor expansion probabilistic algorithm applies primitive independent input state preparation fig stop moment first successful postselection ancillas happens contrast coherent one fig leverage quantum amplitude amplification briefly discus next figure probabilistic versus coherent master qite algorithm probabilistic approach repeatedly applies unitary generated primitive independent preparation _\mathcal post-selection successful i.e measurement ancillas return outcome take average 1/p_\psi repetition priori knowledge input state required fully generic even mixed coherent approach based quantum amplitude amplification operates pure input state input state mixed extra ancillary register pur pur qubits required purify case quantum gibbs state sampling purification maximally mixed state primitive repeated applied sequentially preparation interleaved reflection operator around state =u_ f_\beta _\mathcal respectively practice requires full priori knowledge total number repetition primitive 1/\sqrt p_\psi desired output obtained probability close hence coherent master algorithm display significantly lower overall query complexity probabilistic one however return former requires much larger circuit depth latter full size image coherent amplification process realized repeatedly applying =u_ f_\beta unitary operator aligned u_\text eng =r_ aligned respectively reflection operator around pur former reflection turn decomposed =u_ f_\beta f_\beta f_\beta inverse block-encoding f_\beta qite propagator f_\beta reflection around unitary u_\text eng sometimes referred amplification engine importantly u_\text eng act 2-dimensional subspace spanned target rotation k\in give aligned u_\text eng ^k\ 2k+1 target +\cos 2k+1 aligned =\alpha f_\beta hence taking k=k_ opt 1/\theta yield 2k+1 therefore probability close desired output entail 1/\alpha f_\beta 1/\sqrt p_\psi repetition primitive finally since ^2\vert f_\beta general unknown one priori knowledge opt however fortunately accounted successive attempt randomly chosen within range value grows exponentially number attempt see theorem remarkably resulting average number application primitive remains within 1/\sqrt p_\psi minimum query complexity qite primitive based block-encoding oracle proof strategy theorem analogous no-fast-forwarding theorem real-time evolution based reduction qite task determining parity par =x_ n-1 bit-wise sum unknown -bit string =x_ n-1 parity oracle together known fundamental complexity bound latter task precisely proof relies three fact algorithm find par fewer known number query qite primitive querying oracle appropriate hamiltonian give algorithm find par iii block-encoding oracle synthesized one call three fact established following lemma first lemma proven lower-bounds complexity quantum circuit able obtain par query purpose stated follows lemma let quantum circuit composed -independent gate time -dependent unitary aligned =\sum j=0 x_j aligned j\in n+1 orthogonal basis acting -independent input state upon measurement -independent basis output par probability greater 1/2 0,1\ ^n\ q\ge n/2\rceil\ second lemma proven sec xvii reduces parity finding qite key technical contribution section lemma let 0,1 -bit string aligned 1-e^ -\frac aligned exists -qite-primitive call block-encoding oracle acting -independent input state upon measurement -independent basis output par probability greater 1/2 0,1\ ^n\ finally missing link lemma sub-routine query given query provided following lemma proven sec xviii lemma block-encoding oracle generated single query -independent gate 0,1\ ^n\ see fig s10 circuit. proof theorem three lemma proof theorem straightforward first note left-hand side decrease monotonically hence fixed largest n\in satisfies n=\lfloor defined together lemma implies -qite-primitive synthesized query parity oracle provides quantum circuit determine parity string length virtue lemma query complexity primitive smaller q\ge n/2\rceil =\big note number nearest integer ergo finally comment theorem doe hold qite primitive based real-time evolution rte oracle useful point reason virtue rte no-fast-forwarding theorem single call rte oracle suffices find parity probability greater 1/2 hence query complexity rte oracle lower-bounded parity consideration rte-based qite primitive open question whether similar bound obtained rte-based qite primitive argument