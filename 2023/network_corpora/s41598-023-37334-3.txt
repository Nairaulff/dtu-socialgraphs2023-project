introduction dimensional analysis one powerful tool available physic verify correctness mathematical formula describing physical process however tool alone able spot possible mistake allows fast check highlight faulty operation provides consistent examination whole process nowadays complex simulation derivation performed using computing algorithm taking advantage high-speed calculation numerical correctness due advance computing technology however using complex algorithm spanning thousand source code line divided ten file tend automatically trust result much worse accept blindly moreover bug-free software implementation mitigate impact possible error using countless check code proper testing procedure often time-consuming development therefore appropriate approach use technique could help reduce overall cost software development unfortunately due historical reason high-level programming language lack dimensional check language feature work float integer leaving programmer judgement responsibility keep track semantic meaning leading many potential mistake several library provide dimensional analysis check compile time run-time however shown mckeever evident reticence adopt solution due following reason difficulty using unfamiliar complex library fear adding external dependency concern performance impact possible limitation using external library complex data structure matrix vector existing solution review existing solution available common programming language describe proposed solution present concrete example implementation unit testing discus testing approach performance study provide performance analysis limitation current development along plan improvement addressed limitation future plan conclusion drawn conclusion existing solution comprehensive review several existing solution dimensional analysis programming language found preussner work apple swift two widespread programming language provide native support uom-aware unit measure quantity promoting uom analysis language feature benefit immediate access meaningful error message unfortunately programming language offer native support important topic instead language external library relies generic programming technique popular solution c++ boost.units make possible uom validation compile time main advantage included boost framework comprehensive set library used launchpad feature later included language standard library unfortunately boost quite often seen heavy dependency fortran language physunits module provides support dimensional-aware routine creation solution versatile allowing working f77 f90 code dimension information carried alongside numerical value physunits introduces run-time execution overhead term speed memory usage dimensional analysis limited compiled language python support run-time dimensional analysis check thanks library like pint almost existing library provide native support vectorial computation however vectorial operation high-energy physic two solution clhep eigen provide representation vectorial quantity n-dimensional matrix none built-in support dimensional-aware unit relying primitive numeric type available c++ mention approach first attempt solve specific issue example corsika simulation tool c++ rewrite corsika similar solution address problem combining unit system vector arithmetic approach adopted combine eigen physunits library allowing perform dimensional-aware vector arithmetic without performance penalty implementation improve accuracy lower run-time overhead scientific engineering computation developed univec c++ library allows scalar vector matrix complex quaternion octonions sedenion operation integrating boost.units library feature decided implement library existing uom analysis library wrap easy-to-use interface physicist rely boost :units dimensional check provide class represent -dimensional vector matrix way provide dimensionally correct method common operation vector norm product matrix determinant operation performance solution line boost :units one development objective add perceptible runtime overhead make possible automatic optimization compiler summary function alias available vector matrix type found table complete source code released lgplv3 license found address http method implemented return copy original vector however method result compatible calling class type created in-place version method modifies object instance method start prefix e.g doconj easily differentiated copy version method method usually faster copy data allocate additional memory operation implementation heavily generic template programming shifting cost dimensional check compiling time removing principle run-time overhead however drawback increased usage complexity may discourage non-experienced c++ developer tried mitigate issue providing custom descriptive error message set default quantity alias covering common quantity used physic approach allows easy-to-remember type name defining variable much shorter name canonical name decided keep set alias gauss unit isolated main library development published separated project address http vector operation univec allows writing compact semantically clear code dimensional-check compile-time done using set class shown table representing different type quantity vector matrix implementation tried prioritize clarity performance two objective difficult reconcile fast code tends quite complex difficult read implemented -dimensional cartesian vector class including complex number quaternion single header-only class approach required heavy use template programming however provides two important benefit code duplication significantly reduced got highly optimized implementation method resolution performed compile-time since inheritance virtual function allowing efficient compiler optimization furthermore complexity code due generic programming mitigated using last c++ keywords like requires improve substantially code readability design realized complex number quaternion octonions sedenions method super-set method available cartesian n-\ dimensional vector see table therefore used class entity marking complex quantity vector negative dimensional number way represent complex number vectorc quaternion vectorc etc. enabling disabling method using template parameter however better readability set alias common entity provided shown table solution allowed high degree code reuse painless conversion entity without requiring inheritance virtual method resolution runtime matrix operation development vectorial operation realized matrix operation would needed soon shall also benefit uom validation main difficulty operation available matrix example operation like determinant matrix defined square matrix reason made heavy use c++ concept requires although severely limit usage within project use least c++20 allows clear definition function usage constraint produce meaningful error message condition met design decision matrix dimension set using integer template shown table mean matrix dimension changed runtime allowing non-negligible performance optimization compiler observe table decided limit method implementation one deterministic non-iterative solution omitting method requiring matrix decomposition future release may add support class method allowing calculation eigenvalue eigenvectors matrix l_2\ norm similar quantity floating point limitation tolerance representation floating-point number tricky point software package handle non-integer quantity ieee standard floating-point arithmetic ieee facto standard modern computer c++ support using float double variable type format allows storing number inside fixed size mantissa exponent allowing representation -308 around 15-digits precision one first issue rational number perfectly representable base-10 numeric system expressed base-2 numeric system inevitably introduce rounding error another issue trigonometric transcendental function c++ calculated using series sum truncated specific precision achieved usually problem engineering scientific field interested approximate value calculation given fall known floating-point pitfall however library quite sensitive issue often check two vector parallel perpendicular matrix diagonal action require check result exact value tricky working floating-point quantity manage last issue introduced concept tolerance represented class tolerance class passed template parameter function requires comparing two value equality usually always method starting prefix provide default implementation compare two value equal equal 10th decimal digit approach quite robust advantage relatively fast easy understand different approach required user provide custom class method specific call table list function implemented type vector full size table table list function implemented complex quaternion octonions sedenions addition one presented table full size table table list operator implemented type -dimensional vector quaternion octonions sedenions complex number full size table frame transformation using univec found formula become much simpler use specific coordinate transformation one good example come simulation microscopic electron-molecule non-relativistic interaction center-of-momentum reference frame transformation-matrix represent linear transformation complex transformation easily represented computed chaining multiple simpler transformation translation rotation scaling operation table list ready use reference frame transformation used describe complex frame transformation full size table one make frame transformation using concrete implementation abstract class baseframec3d table present ready-to-use implementation vector easily transformed new reference frame multiple transformation combined describe complex scenario using syntax vector conversion another valuable feature univec changing coordinate system vector conversion type another made via constructor explicit conversion computationally expensive e.g vectorp2d vectorc implicit otherwise e.g vectorc quaternion method useful executing operation vector represented different coordinate system example converting vectorp2d vectorc2d use following code vector use complex quaternion table list class alias implemented univec full size table table list function implemented matrix class full size table table list function implemented matrix class full size table table list function implemented matrix class full size table usage example subsection present two realistic example using univec first example show simple implementation bethe–bloch equation handy formula evaluating energy deposit ionizing charged particle second example show library used elementary particle physic evaluating decay rate w^-\ boson important notice perform calculation using unit natural unit normally used currently support natural unit boost :units plan address issue near future see limitation future plan example presented article available public repository bethe–bloch well-known bethe–bloch formula used calculate mean energy loss charged particle example particle velocity charge unit elementary charge traveling medium electron number density mean excitation energy calculate mean energy-loss using formula aligned -\left\langle =\frac m_e c^2 z^2 e^2 m_e c^2 -\beta ^2\right aligned m_e\ electron rest mass speed light =v/c\ well lorentz factor using univec encode formula compact expression enjoying fully dimensional analysis validation w^- e^- _e\ decay previous example helpful presenting dimensional analysis validation equation contained scalar operation show vector spinor matrix operation combined compact syntax perform advanced calculation example reproduce derivation describes property boson calculate decay rate w^-\ boson electron e^-\ electronic anti-neutrino _e\ shown fig calculate decay matrix element using aligned =\frac g_w _\mu ^\lambda p_1\right p_3\right ^\mu 1-\gamma ^5\right v\left p_4\right aligned ^\mu -matrices dirac–pauli representation ^\lambda represents three possible polarization state aligned ^\mu =\frac 0,1 _l^\mu =\frac m_w p_z 0,0 e\right ^\mu =-\frac 0,1 aligned v\left p_4\right p_3 respectively adjoint particle spinor antiparticle spinor defined aligned u_1 =n\left array p_z e+m p_x+i p_0 e+m array u_2 =n\left array p_x-i p_0 e+m -p_z e+m array v_1 =n\left array p_x-i p_0 e+m -p_z e+m array v_2 =n\left array p_z e+m p_x+i p_0 e+m array aligned n=\sqrt finally calculate average decay rate using aligned =\frac +\left| _l\right| ^2+\left| ^2\right aligned aligned aligned momentum final particle center-of-mass frame figure lowest-order feynman diagram w^-\ boson decay electron anti-neutrino full size image equation dimensional-invalid unit e.g. sum mass energy however natural unit define quantity like mass momentum length etc. equivalent energy unit operation legit unfortunately current implementation doe support natural unit yet forced convert unit perform calculation result code custom class matrix vector complex value produce compact readable code full dimensional check compile time already explained using unit natural choice hep physicist due nature subject handle unit value differ many order magnitude due fact substantial precision loss occur calculation see limitation future plan detail however example presented produced pretty good result near accepted value 10^ -25 method effective software library need efficient reliable procedure validating functionality correctness performance obtained therefore implementing library perform two type test test functionality correctness implemented method test performance compared similar technique calculating operation talk functionality performance test even though source code library carefully written felt need add additional layer verification integrating testing system deliver reliable application defined good software development practice incorporating test-driven development tdd system detail integration presented unit testing additionally chose use two different compiler gcc clang support wide range machine software could run amount code executed test greater according gcovr —the code coverage utility use ensuring good code coverage unit testing univec developed using test-driven development tdd software design paradigm code development testing occur simultaneously integrating unit testing strategy separately test correctness application functionality implement test univec googletest one popular c++ unit testing framework implemented method operator code associated test ensures expected behavior satisfies specification functionality preserved chosen integrate ci/cd another modern software development practice automated integration testing code documentation stage software development use gitlab host repository allowing access provided ci/cd feature commit push gitlab trigger build code run unit test implemented googletest extract annotated c++ file generate online univec documentation using doxygen furthermore end test procedure pipeline several report file generated two file test result one compiler junit_gcc.xml junit_clang.xml one file briefly present code coverage result test run coverage_gcc.xml combined approach ci/cd unit test assures univec functionality maintainability performance study performance comparison existing solution crucial aspect introduction new library compare univec method four different approach performing operation raw using primitive c++ type double semi using boost :units type method eigen using eigen type method blas lapack using openblas lapacke linux accelerate framework macos method primitive c++ type double operation complex implement e.g determinant matrix raw semi approach unavailable given library e.g cofactor matrix blas approach result omitted compare subset operation shown fig procedure performance testing performed using scheme input data generated raw operation using 10000\ random value number operand stored contiguous memory location input data raw copied semi eigen blas univec use meter unit solution uom validation timer started operation performed 10,000 time without multi-threading result stored contiguous memory location timer stopped time spent single operation calculated dividing total time 10,000 result approach compared correctness result raw implementation step repeated time order calculate mean value stdev source code performance analysis available following location http http first repository contains performance test commonly used method matrix vectorc class result displayed fig contrast second one contains performance analysis two method vector dot product matrix determinant vector dimension matrix size 2\times 10\times 10\ two performance project test result collected saved .csv file one operating system available previously mentioned address well result test shown fig performance validation performed two laptop simulate real scenario two operating system configuration following lenovo v17 itl laptop intel core i7-1165g7 2.80 ghz ram ubuntu 22.04.2 lts boost 1.74.0 eigen 3.4.0 univec 1.2 openblas 3.10.0 lapack 3.10.0 compiled gcc 11.2.0 release configuration apple macbook pro laptop apple max cpu max 3.49 ghz ram macos ventura 13.4.1 boost 1.82.0 eigen 3.4.0 univec 1.2 accelerate-1 blas/lapack compiled apple clang version 14.0.3 release configuration conclude univec performs line solution without significant overhead addition compile-time validation reasonable interface performance analysis see blas often show poor performance assume two factor cause overhead calling fortran function c++ code applicable fact perform blas call vector realize blas used operation simd single instruction multiple data fashion could mitigate function calling overhead addition noticed anomaly calculation dot product vector shown fig see performance hit linux/gcc platform seems appear specific dimension definitive explanation phenomenon however suspect bug gcc optimization algorithm issue present macos/clang environment show fig another anomaly found fig macos timing determinant scale well increasing dimensionality believe cause behavior use gaussian elimination method matrix bigger 4\times efficient method available blas efficient plu decomposition different optimization setting applied apple clang compiler plan analyze fix optimization issue near future order performance line implementation figure time needed perform specified vector operation using five different code implementation left side refers linux setup right side refer macos setup plot lower value mean better performance full size image figure time needed perform specified matrix operation using five different code implementation left side refers linux setup right side refer macos setup plot lower value mean better performance full size image figure time needed perform vector dot product different vector size left side refers linux setup right side refer macos setup plot lower value mean better performance full size image figure time needed perform matrix determinant different matrix size left side refers linux setup right side refer macos setup plot lower value mean better performance full size image limitation future plan strongest limitation currently solution work clang version higher equal caused decision use latest c++20 feature like requires constexpr consteval compatibility gcc limited moment use __declspec property attribute give access vector component univec tested msvc icc compiler however expect blocking issue long c++20 supported use boost.units underlying library univec several non-negligible weak point unfortunately seem solution near future first limitation library available part comprehensive framework boost many software developer often see heavy dependency second limitation current implementation based heavy use boost metaprogramming library mpl template meta-programming technique produce error message challenging understand non-experienced software developer w^- e^- _e\ decay present example elementary particle physic calculus implementation however use unit encouraged widespread field plan near future add support boost :units natural unit allowing easy adoption solution hep community proposal introduce support uom-aware unit directly standard language see mateusz pusz talk cppcon approach solve problem presented provide reliable solution steep learning curve plan create another implementation standard library implementation become available however take several year implementation find way c++ standard library last least plan introduce near future simd optimization e.g sse newer avx-512 increase performance order magnitude working vector matrix conclusion paper presented univec solution uom-validation software development aiming improve use vector matrix calculation c++ development brief overview existing uom solution discussed limitation presented solution several specific user-case scenario elaboration univec started internal project designing phase betaboltz project developing project realized benefit integrating uom analysis directly source code virtually removing common cause mistake even solution doe remove source error univec allowed focus main development workflow increasing confidence implementation plan also create native implementation uom-aware implementation published c++ standard library hope similar solution widely accepted development advanced computational calculus scientific community