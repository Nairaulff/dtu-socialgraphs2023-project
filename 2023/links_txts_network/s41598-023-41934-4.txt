Introduction Quantum state preparation is key in many applications that require data input, such as finance 1 , 2 , 3 , chemistry 4 , 5 , 6 , bioinformatics 7 , machine learning 8 , 9 , and optimisation 10 , 11 , 12 . The ability to generate arbitrary quantum states efficiently and effectively, with high accuracy and low depth and gate count, will therefore be important in the future applications of quantum computing. Existing state preparation techniques 13 , 14 , 15 , 16 , 17 typically produce lengthy circuits with many qubit operations, or quantum gates, compromising their implementation on near-term hardware. In this paper, we present a genetic algorithm for state preparation (GASP) which creates circuits for state preparation to a specified accuracy and depth in an evolutionary framework. This work builds on a relatively old idea on the application of genetic algorithms to quantum circuit evolution 18 . For benchmarking purposes, of the methods that produce circuits for exact state preparation 13 , 19 , 20 , we focus here on the method by Shende, Bullock, and Markov (SBM) 14 , which has been encoded in the Qiskit library 21 . The SBM approach produces an n -qubit arbitrary state using a circuit containing no more than \(2^{n+1} - 2n\) CNOT gates. We benchmark the GASP method against Qiskit 21 for Gaussian states and W-states in the context of simulation with gate noise and implementation on physical devices. Because the GASP circuits have much lower depth by design, the prospects for implementation on physical Noisy Intermediate Quantum (NISQ) devices are better, as we will show by explicit examples. A genetic algorithm is a classical optimisation technique that aims to mimic the process of biological evolution 22 . The basic structure of a genetic algorithm is to first establish a population of individuals to evolve. This population can be many individuals or only a single individual. Generic genetic algorithms usually have many individuals and use crossover, however, if the population has only a single individual it is asexual, and only uses mutation. Each individual is an attempted solution to the given problem and is defined by a ‘chromosome’ where each parameter in the chromosome represents a ‘gene’. This population is then subject to an iterative process where the individuals are selected by some selection criteria (rank selection, roulette wheel selection, etc.), and the selected individuals are bred together, and/or mutated. Each iteration of the genetic algorithm is referred to as a ‘generation’. For each generation, the fitness of each individual in the population is evaluated, by some objective fitness function, and the fittest individuals have the highest probability of being bred together, and/or mutated 23 . These individuals then form the next generation of the algorithm, in an effort to iteratively increase the maximum fitness. Generally, the algorithm is completed when a specific fitness is achieved, or when a given number of iterations are run without achieving a specific fitness. This method of optimisation allows solutions to be pulled out of local optima, and move towards global optima. The important aspects of the genetic algorithm approach are as follows (see section “ Methods ” for further details): Initial population/individual In a sexual genetic algorithm the initial population is randomly generated with a specified population size parameter. Ideally, there is a considerable amount of divergence between different individuals, to allow for a broad area of the problem search space to be covered. In an asexual genetic algorithm, the initial population is only a single individual. Each individual in the population is instantiated with a chromosome defining a set of genes, the representation of these is subject to the problem being solved. Examples of possible chromosome representations include binary representations and list representations. Crossover Crossover is the process where two parents are bred together, producing a child that contains one-half of its genomic information from one parent, and one-half from the other. There are various methods of crossover in genetic algorithms, the main two being single-point crossover, and k-point crossover. The crossover point is where in the chromosome ‘list’ the chromosome is split. Single-point crossover is where the crossover point is chosen and the child’s genomic information is taken from one parent before the crossover point, and one parent after the crossover point. k-point crossover is a slightly more generalised version of this process, where there are k crossover points and the genomic information of the child ends up being \(k+1\) sections alternating between parents 24 . Mutation Mutation is the process where individual genes in an individual are randomly mutated, by some probability p , to increase genetic diversity in the population. In sexual genetic algorithms, the mutation rate is set low, as high mutation rates tend towards a primitive random search. In asexual genetic algorithms, the mutation rate is generally higher as it is the only means by which to introduce genetic diversity in the individual. The mutation operation allows the genetic algorithm to have increased genetic diversity, increasing the search space and allowing the algorithm to potentially escape local minima. Selection Selection is the process by which the fittest individuals are chosen for crossover. The procedure generally involves assigning a probability of selection to each individual based on their fitness. There are many selection methods; common methods include roulette wheel selection, rank selection, and tournament selection. In roulette wheel selection each individual is given a probability of being selected dependent on their fitness. This allows the fittest individuals to have the highest probability of passing genes on to the next generation. It also allows lucky unfit individuals to pass their genes on to the next generation, increasing genetic diversity. The advantage of this method is no genetic material is conserved. Rank selection sorts the individuals by fitness and chooses the fittest individuals for crossover. The advantage of this method is you can more quickly converge to an optimal solution by virtue of only taking the fittest individuals. Tournament selection randomly pairs individuals and selects the individual with the higher fitness of the two for crossover. This is an intermediary between the roulette wheel and rank selection, allowing potential faster convergence while maintaining a potentially higher level of genetic diversity. In the quantum circuit space, the introduction of genetic algorithms has focused largely on producing circuits to generate specific unitaries 18 , 24 , 25 , 26 , 27 , 28 , and has been applied to quantum machine learning 29 . The flowchart describing GASP is depicted in Fig. 1 . In this work, the genetic algorithm is designed to evolve quantum circuits for the task of state preparation. In this context, an individual is a quantum circuit, and a gene is a single quantum logic operation (gate) in the given quantum circuit. Figure 1 Overview of the GASP approach, given a desired target state vector \(|\psi _{\mathrm{{target}}}\rangle\) . ( i ) Then, create initial population \(\{P\}\) , of individuals, \(P_i\) , which are each a quantum circuit, that generates the population states \(|\psi (\vec {\theta })_{P}\rangle\) , with the appropriate number of qubits and number of genes for the given state vector. ( ii ) Assess the fitness of the state vectors determined by each individual in the population: \(f(|\psi (\vec {\theta })_{P_i}\rangle ) = |\langle \psi _{\mathrm{{target}}}|\psi (\vec {\theta })_{P_i}\rangle |^2\) . ( iii ) Apply crossover to the population, producing \(|\psi (\vec {\theta })_{\mathrm{{new}}}\rangle\) . ( iv ) Mutate the entire population with probability \(p=5\%\) . ( v ) Run classical optimisation on each mutated individual to obtain the optimal \(\theta\) values between 0 and \(2\pi\) , to achieve the highest fitness for their generated circuit. ( vi ) Apply roulette wheel selection to the population, to select the individuals for the next generation based on their assessed fitness. ( vii ) Repeat until the desired fitness is achieved or maxiter iterations since the last increase in fitness was achieved. ( viii ) If maxiter iterations since the last increase in fitness, increase the number of genes by 1 and return to ( i ). Full size image The structure of the paper is as follows. Section “ Results ” will present the results, section “ Methods ” will describe the method presented in detail, and section “ Discussion ” our conclusions and potential future work. Results Gaussian states Gaussian states have relatively low entanglement and are defined as, $$\begin{aligned} |\psi _G\rangle = \frac{1}{\sqrt{2^n}} \sum _{i=0}^{2^n-1}g(x)|x\rangle , \end{aligned}$$ (1) where \(g(x) = \frac{1}{\sigma \sqrt{2\pi }}\exp {(-\frac{1}{2}\frac{(x - \mu )^2}{\sigma ^2})}\) , \(\mu\) is the mean, and \(\sigma\) is the standard deviation of the desired Gaussian. For the purposes of this paper, we let \(\mu = \frac{2^n}{2}\) , and \(\sigma = \frac{2^n}{8}\) . In Fig. 2 a we show an example GASP circuit, comparing the depth and gate count with that produced by Qiskit’s initialise function. A comparison of the states produced by Qiskit’s initialise function, and GASP, in the absence of noise, is shown in Fig. 2 b for a 6 qubit Gaussian state. In the zero-noise regime, the data shows that the Qiskit method produces the target exactly as expected, and the GASP is within the specified fidelity tolerance (99% in this case). For the same 6 qubit Gaussian, a comparison of the states produced by Qiskit’s initialise function, and GASP simulated, in the presence of noise (modelled from ibmq_guadalupe ) is shown in Fig. 2 c, 16,384 shots were used. It can be seen that GASP performs much better in reproducing the desired target state vector in the presence of noise, though not perfectly. This shows that a slight reduction in the accuracy of the circuit, for a large reduction in circuit depth improves the desired outcome state in the presence of noise. GASP producing circuits shorter by orders of magnitude allow more realistic circuits to be implemented on NISQ-era hardware. Figure 2 d shows the comparison between GASP and Qiskit for Gaussian states, in terms of gate scaling vs. the number of qubits. Figure 2 e shows the improved performance of the circuits generated by GASP relative to Qiskit when simulated with noise, and run on IBM’s ibmq_guadalupe machine, averaged over 10 tests as the number of qubits varied from 2 to 10 (noting that this measure does not include the phase information). Figure 2 ( a ) Comparison between sample solution circuits generated by GASP and Qiskit for a 6 qubit Gaussian. GASP produced a circuit with a depth of 13 and 35 gates, Qiskit produced a circuit with a depth of 120 and 125 gates. Note: these are circuits before compilation on real hardware. ( b ) Comparison between Qiskit and GASP (99% fidelity) resultant distributions with no noise for a 6 qubit Gaussian state. The grey dashed line is the exact distribution, the orange bars are GASP, and the blue bars are Qiskit. ( c ) Comparison between Qiskit and GASP (99% fidelity) resultant distributions in the presence of noise for a 6 qubit Gaussian state. The noise model is that of IBM’s ibmq_guadalupe machine. 16,384 shots were used. The grey dashed line is the exact distribution without noise, the orange bars are GASP, and the blue bars are Qiskit. ( d ) Gate comparison between the Qiskit and GASP (99% fidelity) for Gaussian states as the number of qubits varied from 2 to 10. ( e ) Comparison between GASP (99% fidelity) and Qiskit for Gaussian states as the number of qubits varied from 2 to 10. Lines represent simulations with noise, crosses represent results from IBM’s ibmq_guadalupe machine. 16,384 shots were used. The noise model is that of IBM’s ibmq_guadalupe machine. Full size image W-states W-states generally have higher entanglement and are defined as, $$\begin{aligned} |\psi _W\rangle = \frac{1}{\sqrt{n}}(|100\ldots 0\rangle + |010\ldots 0\rangle + \cdots + |000\ldots 1\rangle ), \end{aligned}$$ (2) where n is the number of qubits. In Fig. 3 a we show an example GASP circuit, comparing the depth and gate count with that produced by Qiskit’s initialise function. A comparison of the produced states by Qiskit’s initialise function, and GASP, with no noise, is shown in Fig. 3 b. Figure 3 c shows the comparison between Qiskit and GASP (99% fidelity) resultant distributions in the presence of noise for a 6 qubit W state. The noise model is that of IBM’s ibmq_guadalupe machine. 16,384 shots were used. The grey dashed line is the exact distribution without noise, the orange bars are GASP, and the blue bars are Qiskit. Figure 3 d shows the comparison between the Qiskit and GASP (99% fidelity) for W-states as the number of qubits varied from 2 to 10. Figure 3 e shows the performance of the circuits generated by GASP and Qiskit when simulated with noise, averaged over 10 tests as the number of qubits varied from 2 to 10 noting that this measure does not include the phase information. Figure 3 ( a ) Comparison between sample solution circuits generated by GASP and Qiskit for a 6 qubit W state. GASP produced a circuit with a depth of 22 and 59 gates, and Qiskit produced a circuit with a depth of 120 and 125 gates. Note: these are circuits before compilation on real hardware. ( b ) Comparison between Qiskit and GASP (99% fidelity) resultant distributions with no noise for a 6 qubit W state. The grey dashed line is the exact distribution, the orange bars are GASP, and the blue bars are Qiskit. ( c ) Comparison between Qiskit and GASP (99% fidelity) resultant distributions in the presence of noise for a 6 qubit W state. The noise model is that of IBM’s ibmq_guadalupe machine. 16,384 shots were used. The grey dashed line is the exact distribution without noise, the orange bars are GASP, and the blue bars are Qiskit. ( d ) Comparison between the Qiskit and GASP (99% fidelity) for W-states as the number of qubits varied from 2 to 10. ( e ) Comparison between GASP (99% fidelity) and Qiskit for W-states as the number of qubits varied from 2 to 10. Lines represent simulations with noise, crosses represent results from IBM’s ibmq_guadalupe machine. 16,384 shots were used. The noise model is that of IBM’s ibmq_guadalupe machine. Full size image As can be seen in the results shown here, GASP consistently outperforms Qiskit in the number of total gates and the number of CNOT gates required; by more than two orders of magnitude in the higher qubit tests. It seems that GASP is a lower polynomial complexity in the number of gates required compared to Qiskit’s initialisation method. It should be noted that the number of gates required for the Gaussian state generation is fewer than that of the W-states. This is likely due to Gaussian states being less entangled than W-states. It can be seen that the circuits produced by GASP have higher noise robustness than circuits produced by Qiskit’s initialisation. However, the length of circuits produced by both techniques at high numbers of qubits have so many gates that the noise overwhelms the ability of the circuit to produce the desired state. It should also be noted that at useful fidelities (those above 50%), GASP outperforms Qiskit’s initialisation. Methods In GASP, a gene is represented, $$\begin{aligned} \textrm{gene} = [\textit{q}_{\mathrm{{t}}}^\textit{i}, \textit{G}^\textit{i}, \textit{q}_{\mathrm{{c}}}^\textit{i}, \theta ^\textit{i}], \end{aligned}$$ (3) and an individual is represented, $$\begin{aligned} P_i = [\textrm{gene}_1, \textrm{gene}_2,\hdots , \textrm{gene}_n], \end{aligned}$$ (4) where each gene \((i = 0\ldots n)\) represents a gate application, \(q_t\) is the target qubit, G is the chosen gate type from \(\{R_x, R_y, R_z, \textrm{CNOT}\}\) , \(q_c\) is the control qubit if any, and \(\theta\) is the rotation angle in the chosen gate. For a single qubit gate, \(q_c\) is set to None. For a two-qubit gate \(q_c\) is set to another qubit in the circuit, and \(\theta\) is set to None, allowing the classical optimisation to only optimisation single-qubit rotation angles. The number of genes in an individual is dependent on how many gates the circuit contains. As such, a mutation in the genetic algorithm would be the changing of certain gates with a given probability. Crossover The crossover method used in GASP is a simple 1-point crossover with one half from each parent, applied to every generation (i.e. crossover point is 50%). In the quantum circuit context, this results in a new circuit containing half the gates from the first individual, and half the gates from the second individual. Mutation Mutation in GASP is applied every generation. The default probability for mutation is \(5\%\) , however, this parameter can be varied dependent on the problem to be solved. The basic mutation of a quantum circuit changes certain genes in the individual to other genes, resulting in different gates for the quantum circuit, changing the resultant state vector. Fitness Given the target state vector, \(|\psi _{\mathrm{{target}}}\rangle\) , and the resultant state vector of the current individual, \(|\psi (\vec {\theta })_{P_i}\rangle\) , GASP searches for the individual whose circuit produces the highest fitness. The fitness is calculated by the cost function, $$\begin{aligned} f(|\psi (\vec {\theta })_{P_i}\rangle ) = |\langle \psi _{\mathrm{{target}}}|\psi (\vec {\theta })_{P_i}\rangle |^2, \end{aligned}$$ (5) the norm squared of the inner product between the target state vector and the individual’s state vector, which is the similarity between the target state vector and the individual’s state vector. The fitness of the individual will always be a value between 0 and 1. Selection The method of selection used in GASP is roulette wheel selection. This allows genetic diversity to be maintained through generations of the algorithm, while also increasing fitness. This is done by initially summing the total fitness of the entire population of individuals, \(f_T\) , then giving each individual a normalised fitness relative to the fitness of the entire population, \(p (|\psi (\vec {\theta })_{P}\rangle )\) , i.e, $$f_T = \sum _i f(|\psi (\vec {\theta })_{P_i}\rangle ),$$ (6) $$p(|\psi (\vec {\theta })_{P_i}\rangle ) = \frac{f(|\psi (\vec {\theta })_{P_i}\rangle )}{f_T}.$$ (7) The individuals in the next generation are then selected based on their respective fitnesses. Algorithm For a chosen \(|\psi _{\mathrm{{target}}}\rangle\) , a population of individuals is produced each with a certain number of ‘genes’ based on the entanglement of the target state. The individual is the quantum circuit. Each ‘gene’ is one of the four gates identified in the universal set listed in section “ Methods ”; \(\{R_x, R_y, R_z, \textrm{CNOT}\}\) . The fitness of each individual is then assessed with the fitness function. Crossover is then applied to the population, to produce new individuals, doubling the population. Each individual in the population is then ‘mutated’ at a probability of \(5\%\) . SLSQP optimisation 30 is then run on each individual in the population to find the optimal \(\theta\) ’s for each given individual. The population is then subject to roulette wheel selection, to select the individuals for the next generation, halving the population back down to its original size. This process is then repeated, iteratively increasing the best fitness of the population. If the desired fitness is not achieved within maxiter (1000 in the presented results) iterations of the last increase in fitness, the number of genes for each individual is increased by one, and the process restarts. Once a desired target state vector \(|\psi _{\textrm{target}}\rangle\) (which also determines the number of qubits) is selected GASP can be broken down into the following steps: a. The initial population \(\{P\}\) , of individuals, \(P_i\) , is created, that dictates the trial state vectors \(|\psi (\vec {\theta })_{P_i}\rangle\) , with the appropriate number of qubits and number of genes for the given state vector b. The fitness of the state vectors determined by each individual in the population: \(f(|\psi (\vec {\theta })_{P_i}\rangle ) = |\langle \psi _{\mathrm{{target}}}|\psi (\vec {\theta })_{P_i}\rangle |^2\) is assessed c. Crossover is applied to the population, generating \(|\psi (\vec {\theta })_{\mathrm{{new}}}\rangle\) d. The entire population is mutated with probability \(p=5\%\) . e. Classical optimisation is run on each mutated individual to obtain the optimal \(\vec {\theta }\) values between 0 and \(2\pi\) , which achieve the highest fitness for their generated circuit f. Roulette wheel selection is applied to the population, to select the individuals for the next generation based on their assessed fitness. g. Steps ii–vi are repeated until the desired fitness is achieved or maxiter (where maxiter is a parameter set prior to the start of the algorithm) iterations since the last increase in fitness was achieved h. If maxiter iterations since the last increase in fitness are achieved, increase the number of genes by 1 and return to step i In GASP, the genetic algorithm is being utilised to determine the course-grained optimisation of quantum circuit structure, while a much better fine-grained algorithm, SLSQP, was used for determining the optimal angles for each circuit structure generated. This allows the optimal, or at least close to optimal, fitness for each generated circuit structure to be achieved. Discussion In this paper, we have proposed and demonstrated a state preparation method based on a genetic evolutionary approach. Benchmarking GASP against Qiskit’s initialisation method, the results show that in the noisy regime relevant to implementation on actual hardware, GASP significantly outperforms the exact approach through superior circuit compression, by more than an order of magnitude. As GASP is a stochastic algorithm, there is an increase in run time over the deterministic algorithms and an introduced uncertainty in the ability to produce a solution. However, the significant reduction in both the total gate count and the number of required CNOT gates may outweigh these for the application of GASP to the initialisation of quantum states in circuit lengths feasible on NISQ-era hardware. As GASP is a general technique that works for any given state, further work beyond this paper will include using GASP to generate more general quantum state preparation problems, such as amplitude-encoded image data, particle physics data, and biological data. Additionally, as this work is all classical simulation of quantum states, it would be interesting future work to develop a cost function so that GASP could be run on an actual quantum computer. Note: During the preparation of this work, a recent paper by Rindell et al. 31 studying state preparation using a genetic algorithm was posted on the arXiv. Their method is similar to the GASP approach presented here, though differs in that they used a Fast Non-dominated Sorting Genetic Algorithm implemented in the DEAP Python package 32 , and a different gate set of \(\{R_z(\theta ), X, \sqrt{X}, \mathrm {CNOT\}}\) . They also do not use classical optimisation, instead opting to adjust \(\theta\) by adding a value from a selected Gaussian distribution. Their method was applied to the production of Haar random states up to 5 qubits, demonstrating similar fidelity improvements in the presence of noise.